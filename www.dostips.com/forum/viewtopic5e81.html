<!DOCTYPE html>
<html dir="ltr" lang="en-gb">

<!-- Mirrored from www.dostips.com/forum/viewtopic.php?f=3&t=7396&view=print by HTTrack Website Copier/3.x [XR&CO'2014], Fri, 19 Oct 2018 06:28:24 GMT -->
<!-- Added by HTTrack --><meta http-equiv="content-type" content="text/html;charset=UTF-8" /><!-- /Added by HTTrack -->
<head>
<meta charset="utf-8" />
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="robots" content="noindex" />

<title>DosTips.com &bull; Read key presses via REPLACE - New functions :getKey, :getAnyKey, :getMaskedInput</title>

<link href="styles/AllanStyle-SUBSILVER/theme/print.css" rel="stylesheet">
</head>
<body id="phpbb">
<div id="wrap" class="wrap">
	<a id="top" class="top-anchor" accesskey="t"></a>

	<div id="page-header">
		<h1>DosTips.com</h1>
		<p>A Forum all about DOS Batch<br /><a href="index-2.html">https://www.dostips.com/forum/</a></p>

		<h2>Read key presses via REPLACE - New functions :getKey, :getAnyKey, :getMaskedInput</h2>
		<p><a href="viewtopic20ae.html?f=3&amp;t=7396">https://www.dostips.com/forum/viewtopic.php?f=3&amp;t=7396</a></p>
	</div>

	<div id="page-body" class="page-body">
		<div class="page-number">Page <strong>1</strong> of <strong>2</strong></div>
					<div class="post">
				<h3>Read key presses via REPLACE - New functions :getKey, :getAnyKey, :getMaskedInput</h3>
				<div class="date">Posted: <strong>05 Sep 2016 12:50</strong></div>
				<div class="author">by <strong>dbenham</strong></div>
				<div class="content"><span style="font-size: 150%; line-height: normal"><span style="color: #BF0000"><strong class="text-strong">Version 2, with new behavior and bug fixes, is available at </strong></span><a href="viewtopiceee9.html?f=3&amp;t=7396&amp;p=50819#p50819" class="postlink">http://www.dostips.com/forum/viewtopic.php?f=3&amp;t=7396&amp;p=50819#p50819</a></span><br /><br />In the past I have used the XCOPY method to read key presses. I first <a href="viewtopicdde1.html?f=3&amp;t=4741&amp;start=15#p27382" class="postlink">learned of the XCOPY method while developing SNAKE.BAT</a>. However, it does not support all possible characters. For example, I could not figure out a way to capture &lt;Ctrl-Z&gt; (0x1A). Also, it is difficult, though possible, to distinguish LineFeed (0x0A) from Carriage Return (0x0D). And ! is also a bit difficult to get.<br /><br />I only recently read Carlos' thread where he uses REPLACE to read a key: <a href="viewtopic939a.html?f=3&amp;t=6382" class="postlink">Password Input (new method)</a> - most excellent <img class="smilies" src="images/smilies/icon_exclaim.gif" alt=":!:" title="Exclamation" /><br />I find REPLACE much easier to use, and am able to capture <strong class="text-strong"><em class="text-italics">all</em></strong> possible single byte characters,  <span style="color: #0000FF"><strong class="text-strong">including NULL (0x00)</strong></span>.<br />Using this basic technique, I have developed three robust functions that share the following key features:<br /><ul><li> Each function has an option to specify which characters are accepted</li><li> Each function works regardless whether delayed expansion is enabled or disabled</li><li> Full documentation is embedded within comments at the top of each function</li></ul><br /><strong class="text-strong">:getAnyKey</strong> - Capture any character, <span style="color: #0000FF"><strong class="text-strong">including</strong></span> NULL. Some characters can only be entered using &lt;Alt&gt; with the numeric keypad. <span style="color: #0000FF"><strong class="text-strong">Null is entered using [Ctrl-2] and is returned as an empty string (undefined variable).</strong></span><br /><br /><strong class="text-strong">:getKey</strong> - Same as <strong class="text-strong">:getAnyKey</strong> except Null, LineFeed, CarriageReturn, <span style="color: #0000FF"><strong class="text-strong">(and sometimes Ctrl-Z)</strong></span> are all reported as an empty string (undefined variable)<br /><br /><strong class="text-strong">:getMaskedInput</strong> - Similar to the carlos :<strong class="text-strong">PasswordInput</strong> function, with the added ability to specify which characters are accepted, and delayed expansion need not be enabled. This function is dependent on the :<strong class="text-strong">getKey</strong> function.<br /><br /><div class="codebox"><p>Code: <a href="#" onclick="selectCode(this); return false;">Select all</a></p><pre><code>::getMaskedInput&nbsp; StrVar&nbsp; &#91;ValidVar&#93;<br />::<br />:: Get a user input string, echoing * for each key pressed. &#91;Backspace&#93; erases<br />:: the previous character. &#91;Enter&#93; completes the string. Additionally, any<br />:: method that generates Null (0x00), LineFeed (0x0A) or Carriage Return (0x0D)<br />:: will also terminate the string. On Windows 10 a &#91;Ctrl-Z&#93; (0x1A) will also<br />:: terminate the string. The final string may contain any characters between<br />:: 0x01 and 0xFF except Backspace, LineFeed, and Carriage Return. On Windows 10<br />:: Ctrl-Z is also excluded.<br />::<br />:: The optional ValidVar variable defines the characters that will be accepted.<br />:: If not specified or not defined, then all characters are accepted.<br />:: If specified and defined, then only characters within ValidVar are accepted.<br />::<br />:: Any value (except null) may be entered by holding the &#91;Alt&#93; key and pressing<br />:: the appropriate decimal code on the numeric keypad. For example, holding<br />:: &#91;Alt&#93; and pressing numeric keypad &#91;1&#93; and &#91;0&#93;, and then releasing &#91;Alt&#93; will<br />:: result in a LineFeed.<br />::<br />:: The only way to enter a Null is by holding &#91;Ctrl&#93; and pressing the normal &#91;2&#93;<br />::<br />:: An alternate way to enter control characters 0x01 through 0x1A is by holding<br />:: the &#91;Ctrl&#93; key and pressing any one of the letter keys &#91;A&#93; through &#91;Z&#93;.<br />:: However, &#91;Ctrl-A&#93;, &#91;Ctrl-F&#93;, &#91;Ctrl-M&#93;, and &#91;Ctrl-V&#93; will be blocked on Win 10<br />:: if the console has Ctrl key shortcuts enabled.<br />::<br />:: This function works properly regardless whether delayed expansion<br />:: is enabled or disabled.<br />::<br />:: :getMaskedInput version 1.2 was written by Dave Benham, and originally<br />:: posted at http://www.dostips.com/forum/viewtopic.php?f=3&amp;t=7396<br />::<br />:: This work was inspired by posts from carlos and others at<br />:: http://www.dostips.com/forum/viewtopic.php?f=3&amp;t=6382<br />::<br />:getMaskedInput<br />setlocal<br />set &quot;notDelayed=!&quot;<br />setlocal enableDelayedExpansion<br />set &quot;mask=!%2!&quot;<br />for /f %%A in ('&quot;Prompt;$H&amp;for %%A in (1) do rem&quot;') do set &quot;BS=%%A&quot;<br />if defined mask set &quot;mask=1!BS!!mask!&quot;<br />set &quot;str=&quot;<br />:getMaskedInputLoop<br />call :getKey key mask<br />if defined key (<br />&nbsp; if not defined notDelayed (<br />&nbsp; &nbsp; if &quot;!key!&quot; equ &quot;^!&quot; set &quot;key=^^^!&quot;<br />&nbsp; &nbsp; if &quot;!key!&quot; equ &quot;^&quot; set &quot;key=^^&quot;<br />&nbsp; )<br />&nbsp; if &quot;!key!&quot; equ &quot;!BS!&quot; (<br />&nbsp; &nbsp; if defined str (<br />&nbsp; &nbsp; &nbsp; set &quot;str=!str:~0,-1!&quot;<br />&nbsp; &nbsp; &nbsp; &lt;nul set /p &quot;=%BS% %BS%&quot;<br />&nbsp; &nbsp; )<br />&nbsp; ) else (<br />&nbsp; &nbsp; set &quot;str=!str!!key!&quot;<br />&nbsp; &nbsp; &lt;nul set /p &quot;=*&quot;<br />&nbsp; )<br />&nbsp; goto :getMaskedInputLoop<br />)<br />for /f &quot;delims=&quot; %%A in (&quot;&quot;!str!&quot;&quot;) do (<br />&nbsp; endlocal<br />&nbsp; endlocal<br />&nbsp; set &quot;%1=%%~A&quot; !<br />&nbsp; echo(<br />&nbsp; exit /b<br />)<br /><br /><br />::getKey&nbsp; KeyVar&nbsp; &#91;ValidVar&#93;<br />::<br />:: Read a keypress representing a character between 0x00 and 0xFF and store the<br />:: value in variable KeyVar. Null (0x00), LineFeed (0x0A), and Carriage Return<br />:: (0x0D) will result in an undefined KeyVar. On Windows 10, Ctrl-Z (0x1A) will<br />:: also result in an undefined KeyVar. The simplest way to get an undefined<br />:: KeyVar is to press the &#91;Enter&#93; key.<br />::<br />:: The optional ValidVar variable defines the values that will be accepted.<br />:: If not given or not defined, then all characters are accepted. If given<br />:: and defined, then only characters within ValidVar are accepted. The first<br />:: character within ValidVar should either be 0, meaning ignore undefined KeyVar,<br />:: or 1, meaning accept undefined KeyVar. The remaining characters represent<br />:: themselves. For example, a ValidVar value of 0YNyn will only accept upper<br />:: or lower case Y or N. A value of 1YNyn will additionally accept &#91;Enter&#93; etc.<br />::<br />:: Any value (except null) may be entered by holding the &#91;Alt&#93; key and pressing<br />:: the appropriate decimal code on the numeric keypad. For example, holding<br />:: &#91;Alt&#93; and pressing numeric keypad &#91;1&#93; and &#91;0&#93;, and then releasing &#91;Alt&#93; will<br />:: result in a LineFeed.<br />::<br />:: The only way to enter a Null is by holding &#91;Ctrl&#93; and pressing the normal &#91;2&#93;<br />::<br />:: An alternate way to enter control characters 0x01 through 0x1A is by holding<br />:: the &#91;Ctrl&#93; key and pressing any one of the letter keys &#91;A&#93; through &#91;Z&#93;.<br />:: However, &#91;Ctrl-A&#93;, &#91;Ctrl-F&#93;, &#91;Ctrl-M&#93;, and &#91;Ctrl-V&#93; will be blocked on Win 10<br />:: if the console has Ctrl key shortcuts enabled.<br />::<br />:: This function works properly regardless whether delayed expansion is enabled<br />:: or disabled.<br />::<br />:: :getKey version 1.3 was written by Dave Benham, and originally posted at<br />:: http://www.dostips.com/forum/viewtopic.php?f=3&amp;t=7396<br />::<br />:: This work was inspired by posts from carlos and others at<br />:: http://www.dostips.com/forum/viewtopic.php?f=3&amp;t=6382<br />::<br />:getkey<br />set &quot;%1=&quot;<br />setlocal disableDelayedExpansion<br />for /f skip^=1^ delims^=^ eol^= %%A in (<br />&nbsp; 'replace.exe ? . /u /w'<br />) do for /f delims^=^ eol^= %%B in (&quot;%%A&quot;) do (<br />&nbsp; endlocal<br />&nbsp; if &quot;%%B&quot; equ &quot;&quot; (set &quot;%1=^!&quot;) else set &quot;%1=%%B&quot;<br />)<br />setlocal enableDelayedExpansion<br />if &quot;!%2!&quot; neq &quot;&quot; (<br />&nbsp; if not defined %1 if &quot;!%2:~0,1!&quot; equ &quot;0&quot; (endlocal&amp;endlocal&amp;goto :getKey) else exit /b<br />&nbsp; set &quot;getKey.key=!%1!&quot;<br />&nbsp; set &quot;mask=!%2:~1!&quot;<br />&nbsp; if not defined mask endlocal&amp;endlocal&amp;goto :getKey<br />&nbsp; if &quot;!getKey.key!&quot; equ &quot;=&quot; (<br />&nbsp; &nbsp; set &quot;test=a!mask!&quot;<br />&nbsp; &nbsp; for /f &quot;delims=&quot; %%A in (&quot;!test!&quot;) do if /i &quot;!test:%%A=%%A!&quot; equ &quot;!test!&quot; endlocal&amp;endlocal&amp;goto :getKey<br />&nbsp; )<br />&nbsp; for /f delims^=^ eol^= %%A in (&quot;!getKey.key!&quot;) do if &quot;!mask:*%%A=!&quot; equ &quot;!mask!&quot; endlocal&amp;endlocal&amp;goto :getKey<br />)<br />exit /b<br /><br /><br />::getAnyKey&nbsp; KeyVar&nbsp; &#91;ValidVar&#93;<br />::<br />:: Read a keypress representing any character between 0x00 and 0xFF and store<br />:: the character in variable KeyVar. A Null value of 0x00 is represented as an<br />:: undefined KeyVar.<br />::<br />:: The optional ValidVar variable holds the characters that will be accepted.<br />:: If not specified or not defined, then all values are accepted. If specified<br />:: and defined, then only characters within ValidVar are accepted. The first<br />:: three characters indicate whether Null (0x00), LineFeed (0x0A), and Carriage<br />:: Return (0x0D) are accepted, respectively. A value of 1 indicates acceptance,<br />:: and 0 indicates rejection. The remaining characters represent themselves.<br />:: For example, a ValidVar value of 000YNyn will only accept upper or lower case<br />:: Y or N. A value of 011YNyn will additionally accept LineFeed and Carriage<br />:: Return. A value of 111YNyn adds Null to the list.<br />::<br />:: Note that &#91;Enter&#93; is interpreted as a Carriage Return.<br />::<br />:: Any value (except null) may be entered by holding the &#91;Alt&#93; key and pressing<br />:: the appropriate decimal code on the numeric keypad. For example, holding<br />:: &#91;Alt&#93; and pressing numeric keypad &#91;1&#93; and &#91;0&#93;, and then releasing &#91;Alt&#93; will<br />:: result in a LineFeed.<br />::<br />:: The only way to enter a Null is by holding &#91;Ctrl&#93; and pressing the normal &#91;2&#93;<br />::<br />:: An alternate way to enter control characters 0x01 through 0x1A is by holding<br />:: the &#91;Ctrl&#93; key and pressing any one of the letter keys &#91;A&#93; through &#91;Z&#93;.<br />:: However, &#91;Ctrl-A&#93;, &#91;Ctrl-F&#93;, &#91;Ctrl-M&#93;, and &#91;Ctrl-V&#93; will be blocked on Win 10<br />:: if the console has Ctrl key shortcuts enabled.<br />::<br />:: This function works properly regardless whether delayed expansion is enabled<br />:: or disabled.<br />::<br />:: :getAnyKey version 1.3 was written by Dave Benham, and originally posted at<br />:: http://www.dostips.com/forum/viewtopic.php?f=3&amp;t=7396<br />::<br />:: This work was inspired by posts from carlos and others at<br />:: http://www.dostips.com/forum/viewtopic.php?f=3&amp;t=6382<br />::<br />:getAnyKey<br />setlocal<br />set &quot;notDelayed=!&quot;<br />setlocal disableDelayedExpansion<br />for /f &quot;skip=1 delims=&quot; %%A in (<br />&nbsp; 'replace.exe ? . /u /w ^| findstr /n &quot;^&quot; ^| find /n /v &quot;&quot;'<br />) do set &quot;str=%%A&quot;<br />setlocal enableDelayedExpansion<br />if &quot;!str!&quot; equ &quot;&#91;2&#93;2:&quot; (&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;%= Ctrl-Z on Win 10 =%<br />&nbsp; copy nul &quot;%temp%\ctrlZ.tmp&quot; /a &gt;nul<br />&nbsp; for /f &quot;usebackq&quot; %%A in (&quot;%temp%\ctrlZ.tmp&quot;) do set &quot;key=%%A&quot;<br />&nbsp; del &quot;%temp%\ctrlZ.tmp&quot;<br />) else if &quot;!str!&quot; equ &quot;&#91;3&#93;3:&quot; (&nbsp; %= LineFeed =%<br />&nbsp; set &quot;key=&quot;<br />) else if &quot;!str!&quot; equ &quot;&#91;3&#93;&quot; (&nbsp; &nbsp; %= Null = %<br />&nbsp; set &quot;key=NULL&quot;<br />) else (&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;%= All others =%<br />&nbsp; set &quot;key=!str:~-1!&quot;<br />&nbsp; if not defined notDelayed if &quot;!key!&quot; equ &quot;^!&quot; set &quot;key=^^^!&quot;<br />)<br />for /f &quot;delims=&quot; %%A in (&quot;&quot;!key!&quot;&quot;) do (<br />&nbsp; endlocal&amp;endlocal&amp;endlocal<br />&nbsp; set &quot;%1=%%~A&quot;<br />)<br />if not defined %1 (set %1=^<br />%= Do not remove or alter this line =%<br />)<br />setlocal enableDelayedExpansion<br />if !%1! equ NULL (<br />&nbsp; endlocal<br />&nbsp; set &quot;%1=&quot;<br />&nbsp; setlocal enableDelayedExpansion<br />)<br />if &quot;!%2!&quot; equ &quot;&quot; exit /b<br />set &quot;getAnyKey.key=!%1!&quot;<br />set &quot;mask=!%2!&quot;<br />(set LF=^<br />%= Do not remove or alter this line =%<br />)<br />if not defined getAnyKey.key if &quot;!mask:~0,1!&quot; equ &quot;0&quot; (endlocal&amp;goto :getAnyKey) else exit /b<br />if !getAnyKey.key! equ !LF!&nbsp; if &quot;!mask:~1,1!&quot; equ &quot;0&quot; (endlocal&amp;goto :getAnyKey) else exit /b<br />for /f %%A in ('copy /z &quot;%~dpf0&quot; nul') do if !getAnyKey.key! equ %%A if &quot;!mask:~2,1!&quot; equ &quot;0&quot; (endlocal&amp;goto :getAnyKey) else exit /b<br />set &quot;mask=!mask:~3!&quot;<br />if not defined mask endlocal&amp;goto :getAnyKey<br />if &quot;!getAnyKey.key!&quot; equ &quot;=&quot; (<br />&nbsp; set &quot;test=a!mask!&quot;<br />&nbsp; for /f &quot;delims=&quot; %%A in (&quot;!test!&quot;) do if /i &quot;!test:%%A=%%A!&quot; equ &quot;!test!&quot; endlocal&amp;goto :getAnyKey<br />)<br />for /f delims^=^ eol^= %%A in (&quot;!getAnyKey.key!&quot;) do if &quot;!mask:*%%A=!&quot; equ &quot;!mask!&quot; endlocal&amp;goto :getAnyKey<br />exit /b<br /></code></pre></div><br /><br /><strong class="text-strong"><em class="text-italics"><span style="color: #0000FF">EDITS<br />2016-09-06: Bug fix for :getKey and :getAnyKey when ValidVar option not specified. Also documentation modified slightly for all three routines.<br />2016-09-07: Added ability to capture Null in :getAnyKey, and improved documentation of all three routines.<br /></span></em></strong><br /><br />Dave Benham</div>
			</div>
			<hr />
					<div class="post">
				<h3>Re: Read key presses via REPLACE - New functions :getKey, :getAnyKey, :getMaskedInput</h3>
				<div class="date">Posted: <strong>05 Sep 2016 13:45</strong></div>
				<div class="author">by <strong>aGerman</strong></div>
				<div class="content">Dave<br /><br />getMaskedInput works for me, getKey and getAnyKey do not (the input isn't available in the passed variable, it remains undefined). I'll try to find out what happened.<br /><br />Steffen<br /><br /><div class="codebox"><p>Code: <a href="#" onclick="selectCode(this); return false;">Select all</a></p><pre><code>@echo off &amp;setlocal<br />call :getAnyKey out<br />setlocal EnableDelayedExpansion<br />echo !out!<br />pause<br />goto :eof<br /><br />:: your code appended here ...<br /></code></pre></div></div>
			</div>
			<hr />
					<div class="post">
				<h3>Re: Read key presses via REPLACE - New functions :getKey, :getAnyKey, :getMaskedInput</h3>
				<div class="date">Posted: <strong>05 Sep 2016 13:59</strong></div>
				<div class="author">by <strong>aGerman</strong></div>
				<div class="content">Still don't see it with echo switched on.<br />I pressed X and Enter.<br /><div class="codebox"><p>Code: <a href="#" onclick="selectCode(this); return false;">Select all</a></p><pre><code>C:\test&gt;call :getAnyKey out<br /><br />C:\test&gt;setlocal<br /><br />C:\test&gt;set &quot;notDelayed=!&quot;<br /><br />C:\test&gt;setlocal disableDelayedExpansion<br /><br />C:\test&gt;for /F &quot;skip=1 delims=&quot; %A in ('replace.exe ? . /u /w|findstr /n &quot;^&quot;') do set &quot;str=%A&quot;<br /><br />C:\test&gt;set &quot;str=2:X&quot;<br /><br />C:\test&gt;setlocal enableDelayedExpansion<br /><br />C:\test&gt;if &quot;!str!&quot; EQU &quot;2:&quot; (<br />copy nul &quot;C:\Users\steffen\AppData\Local\Temp\ctrlZ.tmp&quot; /a&nbsp; 1&gt;nul<br />&nbsp;for /F &quot;usebackq&quot; %A in (&quot;C:\Users\steffen\AppData\Local\Temp\ctrlZ.tmp&quot;) do set &quot;key=%A&quot;<br />&nbsp;del &quot;C:\Users\steffen\AppData\Local\Temp\ctrlZ.tmp&quot;<br />)&nbsp; else if &quot;!str!&quot; EQU &quot;3:&quot; (set &quot;key=&quot; )&nbsp; else (<br />set &quot;key=!str:~-1!&quot;<br />&nbsp;if not defined notDelayed if &quot;!key!&quot; EQU &quot;^!&quot; set &quot;key=^^^!&quot;<br />)<br /><br />C:\test&gt;for /F &quot;delims=&quot; %A in (&quot;&quot;!key!&quot;&quot;) do (endlocal &amp; endlocal &amp; endlocal<br />&nbsp;set &quot;out=%~A&quot; )<br /><br />C:\test&gt;(endlocal &amp; endlocal &amp; endlocal<br />&nbsp;set &quot;out=X&quot; )<br /><br />C:\test&gt;if not defined out set &quot;out=<br />&quot; The empty line above is critical - DO NOT REMOVE<br /><br />C:\test&gt;if &quot;!!&quot; EQU &quot;&quot; exit /b<br /><br />C:\test&gt;setlocal enableDelayedExpansion<br /><br />C:\test&gt;set &quot;getAnyKey.key=!out!&quot;<br /><br />C:\test&gt;set &quot;mask=!!&quot;<br /><br />C:\test&gt;set &quot;LF=<br />&quot; The empty line above is critical - DO NOT REMOVE<br /><br />C:\test&gt;if !getAnyKey.key! EQU !LF! if &quot;!mask:~0,1!&quot; EQU &quot;0&quot; (endlocal &amp; goto :getAnyKey )&nbsp; else exit /b<br /><br />C:\test&gt;for /F %A in ('copy /z &quot;C:\test\x.bat&quot; nul') do if !getAnyKey.key! EQU %A if &quot;!mask:~1,1!&quot; EQU &quot;0&quot; (endlocal &amp; goto :getAnyKey )&nbsp; else exit /b<br /><br />&nbsp;if &quot;!mask:~1,1!&quot; EQU &quot;0&quot; (endlocal &amp; goto :getAnyKey )&nbsp; else exit /b<br /><br />C:\test&gt;set &quot;mask=!mask:~2!&quot;<br /><br />C:\test&gt;if not defined mask endlocal &amp; goto :getAnyKey<br /><br />C:\test&gt;if &quot;!getAnyKey.key!&quot; EQU &quot;=&quot; (<br />set &quot;test=a!mask!&quot;<br />&nbsp;for /F &quot;delims=&quot; %A in (&quot;!test!&quot;) do if /I &quot;!test:%A=%A!&quot; EQU &quot;!test!&quot; endlocal &amp; goto :getAnyKey<br />)<br /><br />C:\test&gt;for /F delims= eol= %A in (&quot;!getAnyKey.key!&quot;) do if &quot;!mask:*%A=!&quot; EQU &quot;!mask!&quot; endlocal &amp; goto :getAnyKey<br /><br />C:\test&gt;if &quot;!mask:*X=!&quot; EQU &quot;!mask!&quot; endlocal &amp; goto :getAnyKey<br /><br />C:\test&gt;setlocal<br /><br />C:\test&gt;set &quot;notDelayed=!&quot;<br /><br />C:\test&gt;setlocal disableDelayedExpansion<br /><br />C:\test&gt;for /F &quot;skip=1 delims=&quot; %A in ('replace.exe ? . /u /w|findstr /n &quot;^&quot;') do set &quot;str=%A&quot;<br /><br />&quot; \test&gt;set &quot;str=2:<br /><br />C:\test&gt;setlocal enableDelayedExpansion<br /><br />C:\test&gt;if &quot;!str!&quot; EQU &quot;2:&quot; (<br />copy nul &quot;C:\Users\steffen\AppData\Local\Temp\ctrlZ.tmp&quot; /a&nbsp; 1&gt;nul<br />&nbsp;for /F &quot;usebackq&quot; %A in (&quot;C:\Users\steffen\AppData\Local\Temp\ctrlZ.tmp&quot;) do set &quot;key=%A&quot;<br />&nbsp;del &quot;C:\Users\steffen\AppData\Local\Temp\ctrlZ.tmp&quot;<br />)&nbsp; else if &quot;!str!&quot; EQU &quot;3:&quot; (set &quot;key=&quot; )&nbsp; else (<br />set &quot;key=!str:~-1!&quot;<br />&nbsp;if not defined notDelayed if &quot;!key!&quot; EQU &quot;^!&quot; set &quot;key=^^^!&quot;<br />)<br /><br />C:\test&gt;for /F &quot;delims=&quot; %A in (&quot;&quot;!key!&quot;&quot;) do (endlocal &amp; endlocal &amp; endlocal<br />&nbsp;set &quot;out=%~A&quot; )<br /><br />C:\test&gt;(endlocal &amp; endlocal &amp; endlocal<br />&quot; )&nbsp; &quot;out=<br /><br />C:\test&gt;if not defined out set &quot;out=<br />&quot; The empty line above is critical - DO NOT REMOVE<br /><br />C:\test&gt;if &quot;!!&quot; EQU &quot;&quot; exit /b<br /><br />C:\test&gt;setlocal enableDelayedExpansion<br /><br />C:\test&gt;set &quot;getAnyKey.key=!out!&quot;<br /><br />C:\test&gt;set &quot;mask=!!&quot;<br /><br />C:\test&gt;set &quot;LF=<br />&quot; The empty line above is critical - DO NOT REMOVE<br /><br />C:\test&gt;if !getAnyKey.key! EQU !LF! if &quot;!mask:~0,1!&quot; EQU &quot;0&quot; (endlocal &amp; goto :getAnyKey )&nbsp; else exit /b<br /><br />C:\test&gt;for /F %A in ('copy /z &quot;C:\test\x.bat&quot; nul') do if !getAnyKey.key! EQU %A if &quot;!mask:~1,1!&quot; EQU &quot;0&quot; (endlocal &amp; goto :getAnyKey )&nbsp; else exit /b<br /><br />&nbsp;if &quot;!mask:~1,1!&quot; EQU &quot;0&quot; (endlocal &amp; goto :getAnyKey )&nbsp; else exit /b<br /><br />C:\test&gt;setlocal EnableDelayedExpansion<br /><br />C:\test&gt;echo !out!<br />ECHO ist eingeschaltet (ON).<br /><br />C:\test&gt;pause<br />Dr√ºcken Sie eine beliebige Taste . . .</code></pre></div><br />The Batch file is &quot;C:\test\x.bat&quot; (no spaces, no special characters).<br /><br />Steffen</div>
			</div>
			<hr />
					<div class="post">
				<h3>Re: Read key presses via REPLACE - New functions :getKey, :getAnyKey, :getMaskedInput</h3>
				<div class="date">Posted: <strong>05 Sep 2016 14:02</strong></div>
				<div class="author">by <strong>dbenham</strong></div>
				<div class="content">Thanks aGerman. It was a silly bug that appeared when the ValidVar option is not specified. My original tests without a value worked. But then I found a bug and had to modify the code a bit, and forgot to retest without a value.<br /><br />The bug is fixed by moving <strong class="text-strong">setlocal enableDelayedExpansion</strong> to before the test for the presence of the ValidVar option.<br />I've fixed the two routines and modified the version to 1.1 in my first post.<br /><br /><br />Dave Benham</div>
			</div>
			<hr />
					<div class="post">
				<h3>Re: Read key presses via REPLACE - New functions :getKey, :getAnyKey, :getMaskedInput</h3>
				<div class="date">Posted: <strong>05 Sep 2016 14:10</strong></div>
				<div class="author">by <strong>dbenham</strong></div>
				<div class="content">I made a slight change to the documentation of all three routines, and updated the versions in my first post.<br /><br /><br />Dave Benham</div>
			</div>
			<hr />
					<div class="post">
				<h3>Re: Read key presses via REPLACE - New functions :getKey, :getAnyKey, :getMaskedInput</h3>
				<div class="date">Posted: <strong>05 Sep 2016 14:12</strong></div>
				<div class="author">by <strong>aGerman</strong></div>
				<div class="content">Now it returns immediatelly regardless if the second parameter was left out, if it was 00, or 11 <img class="smilies" src="images/smilies/icon_confused.gif" alt=":?" title="Confused" /><br /><br />EDIT Oh I guess that's the expected behavior, isn't it?</div>
			</div>
			<hr />
					<div class="post">
				<h3>Re: Read key presses via REPLACE - New functions :getKey, :getAnyKey, :getMaskedInput</h3>
				<div class="date">Posted: <strong>05 Sep 2016 14:29</strong></div>
				<div class="author">by <strong>dbenham</strong></div>
				<div class="content"><img class="smilies" src="images/smilies/icon_confused.gif" alt=":?" title="Confused" /> I'm not sure I understand what you are experiencing.<br /><br />The 2nd argument is optional, and is passed by reference. If it is not specified, then any value is accepted.<br /><br />Here is an example usage that accepts only alpha-numeric input, as well as LineFeed, and Carriage Return.<br /><div class="codebox"><p>Code: <a href="#" onclick="selectCode(this); return false;">Select all</a></p><pre><code>@echo off &amp;setlocal<br />set &quot;valid=11abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789&quot;<br />call :getAnyKey out valid<br />setlocal EnableDelayedExpansion<br />echo&nbsp; &nbsp; key={!out!}<br />goto :eof<br /><br />:getAnyKey ...<br />etc.<br /></code></pre></div><br />Sample output:<br /><div class="codebox"><p>Code: <a href="#" onclick="selectCode(this); return false;">Select all</a></p><pre><code>C:\test&gt;test<br />&nbsp; &nbsp;key={a}&nbsp; &nbsp; &nbsp; &nbsp; REM - I pressed the lower case &lt;a&gt; key<br /><br />C:\test&gt;test<br />}&nbsp; key={&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; REM - I pressed the &lt;Enter&gt; key<br /><br />C:\test&gt;test<br />&nbsp; &nbsp;key={&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; REM - I held the &lt;Alt&gt; key and pressed &lt;1&gt; and &lt;0&gt; on the numeric keypad<br />}<br /></code></pre></div><br /><br />Dave Benham</div>
			</div>
			<hr />
					<div class="post">
				<h3>Re: Read key presses via REPLACE - New functions :getKey, :getAnyKey, :getMaskedInput</h3>
				<div class="date">Posted: <strong>05 Sep 2016 14:41</strong></div>
				<div class="author">by <strong>aGerman</strong></div>
				<div class="content">Sorry Dave. That was my bad. I was expecting that the functions behave similar to getMaskedInput where you can enter more than one key and the function doesn't return before you hit Enter. Of course you would have named such a function getString rather than getKey <img class="smilies" src="images/smilies/icon_redface.gif" alt=":oops:" title="Embarassed" /> <br /><br />Steffen</div>
			</div>
			<hr />
					<div class="post">
				<h3>Re: Read key presses via REPLACE - New functions :getKey, :getAnyKey, :getMaskedInput</h3>
				<div class="date">Posted: <strong>05 Sep 2016 14:58</strong></div>
				<div class="author">by <strong>dbenham</strong></div>
				<div class="content">No problem <img class="smilies" src="images/smilies/icon_smile.gif" alt=":)" title="Smile" /> <br /><br />:getString is not a bad idea, except &lt;Tab&gt; causes a display problem, especially when &lt;Backspace&gt; is used.<br /><br />:getMaskedInput doesn't have the display problem with &lt;Tab&gt; because all characters are displayed the same.<br /><br />EDIT - Other characters that can cause difficulties for :getString display are the bell character &lt;Ctrl-G&gt; (0x07), and on Windows 10, the Escape character &lt;Alt-27&gt; (0x1B).<br /><br /><br />Dave Benham</div>
			</div>
			<hr />
					<div class="post">
				<h3>Re: Read key presses via REPLACE - New functions :getKey, :getAnyKey, :getMaskedInput</h3>
				<div class="date">Posted: <strong>05 Sep 2016 16:29</strong></div>
				<div class="author">by <strong>aGerman</strong></div>
				<div class="content">Anyway these functions are brilliant Dave <img class="smilies" src="images/smilies/icon_smile.gif" alt=":)" title="Smile" /></div>
			</div>
			<hr />
					<div class="post">
				<h3>Re: Read key presses via REPLACE - New functions :getKey, :getAnyKey, :getMaskedInput</h3>
				<div class="date">Posted: <strong>06 Sep 2016 10:07</strong></div>
				<div class="author">by <strong>jeb</strong></div>
				<div class="content">Cool solution <img class="smilies" src="images/smilies/icon_exclaim.gif" alt=":!:" title="Exclamation" />  <img class="smilies" src="images/smilies/icon_cool.gif" alt="8)" title="Cool" /> <br /><br />I never recognized the REPLACE command.<br /><br />But I would change this bit of code to avoid the second FOR loop.<br /><blockquote><div><cite>dbenham wrote:</cite>) do for /f delims^=^ eol^= %%B in (&quot;%%A&quot;) do (<br />  endlocal<br />  if &quot;%%B&quot; equ &quot;&quot; (set &quot;%1=^!&quot;) else set &quot;%1=%%B&quot;<br />)</div></blockquote><br />To:<br /><div class="codebox"><p>Code: <a href="#" onclick="selectCode(this); return false;">Select all</a></p><pre><code>) do (<br />&nbsp; &nbsp; endlocal <br />&nbsp; &nbsp; IF &quot;^!&quot; == &quot;^!^&quot; (<br />&nbsp; &nbsp; &nbsp; &nbsp; set &quot;%1=^%%A&quot; !<br />&nbsp; &nbsp; ) ELSE (<br />&nbsp; &nbsp; &nbsp; &nbsp; set &quot;%1=%%A&quot;<br />&nbsp; &nbsp; )<br /></code></pre></div><br /><br />jeb</div>
			</div>
			<hr />
					<div class="post">
				<h3>Re: Read key presses via REPLACE - New functions :getKey, :getAnyKey, :getMaskedInput</h3>
				<div class="date">Posted: <strong>06 Sep 2016 10:28</strong></div>
				<div class="author">by <strong>jeb</strong></div>
				<div class="content">And a second suggestion<br /><br />Instead of using piping the output through FINDSTR and using an IF-SWITCH block, it could be made much simpler by using this.<br /><br /><div class="codebox"><p>Code: <a href="#" onclick="selectCode(this); return false;">Select all</a></p><pre><code>:getAnyKey<br />setlocal DisableDelayedExpansion<br />(set str=^<br />%=Do not remove this=%<br />)<br />for /f skip^=1^ delims^=^ eol^= %%A in ('replace.exe ? . /u /w') do set &quot;str=%%A&quot;<br />setlocal EnableDelayedExpansion<br />echo(get:&quot;!str!&quot;<br /></code></pre></div><br /><br />I tested it with <br /><blockquote class="uncited"><div>!^&lt;LF&gt;&lt;CR&gt;&lt;CTRL-Z&gt;</div></blockquote></div>
			</div>
			<hr />
					<div class="post">
				<h3>Re: Read key presses via REPLACE - New functions :getKey, :getAnyKey, :getMaskedInput</h3>
				<div class="date">Posted: <strong>06 Sep 2016 17:21</strong></div>
				<div class="author">by <strong>dbenham</strong></div>
				<div class="content">@jeb - The reason for much of the complexity is because I developed the routines on my Win 10 machine at home, and I just now learned that REPLACE handles &lt;Ctrl-Z&gt; differently on Win 10 than it does on earlier versions.<br /><br />The first line of REPLACE output is always the same (&quot;Press any key to continue . . .&lt;CR&gt;&lt;LF&gt;&quot; on my English machine)<br />It is the remaining line(s) that differ depending on what character is pressed.<br /><br />I will use [Alt-10] to mean &quot;hold the [Alt] key and press numeric keypad [1] followed by [0] and then release [Alt]&quot;.<br /><br />Here is the result I get for the 2nd (and possibly 3rd) line of REPLACE output for various key presses on Win 10 and Win 7:<br /><div class="codebox"><p>Code: <a href="#" onclick="selectCode(this); return false;">Select all</a></p><pre><code>Keypress&nbsp; &nbsp; &nbsp; &nbsp;Win 7&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Win 10<br />--------&nbsp; &nbsp; &nbsp; &nbsp;----------------&nbsp; &nbsp; &nbsp; &nbsp;----------------<br /><br />&#91;Enter&#93;&nbsp; &nbsp; &nbsp; &nbsp; &lt;CR&gt;&lt;CR&gt;&lt;LF&gt;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&lt;CR&gt;&lt;CR&gt;&lt;LF&gt;<br /><br />&#91;Alt-10&#93;&nbsp; &nbsp; &nbsp; &nbsp;&lt;LF&gt;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&lt;LF&gt;<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&lt;CR&gt;&lt;LF&gt;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&lt;CR&gt;&lt;LF&gt;<br /><br />&#91;Alt-26&#93;&nbsp; &nbsp; &nbsp; &nbsp;&lt;Ctrl-Z&gt;&lt;CR&gt;&lt;LF&gt;&nbsp; &nbsp; &nbsp; &nbsp;&lt;CR&gt;&lt;LF&gt;<br /></code></pre></div><br />Note how &lt;Ctrl-Z&gt; is not captured on Win 10. During development I was not aware that Win 7 does capture &lt;Ctrl-Z&gt;.<br /><br /><br /><strong class="text-strong">Regarding your first suggestion for :getKey</strong><br /><br />I wanted to use a very simple algorithm for :getKey and :getMaskedInput. There is no simple way to differentiate between [Alt-26] and [Alt-10], and I wanted [Enter] to be the normal way to end. So I decided I want to treat all three cases the same - and I opted to return nothing if any of those options are pressed.<br /><br />Note that FOR /F strips off only one &lt;CR&gt; if it is the last character in the string, so a single FOR /F preserves &lt;CR&gt; when [Enter] is pressed.<br /><br />So that is why I added the 2nd FOR /F loop to :getKey - to eliminate the &lt;CR&gt; from the output so that [Enter] behaves the same as the other two. I initialize the result to undefined before reading the key, so I get my desired result.<br /><br />The other option would have been to only use one FOR /F, and look at the captured key and check if it was &lt;CR&gt;, but I did not want to add the code to generate a &lt;CR&gt;, which is why I chose the 2nd FOR /F.<br /><br />I now realize that I could have chosen to represent those 3 key presses as &lt;CR&gt;, and then I need only initialize the result to &lt;CR&gt; and I only need one FOR /F loop.<br /><br />The modified IF code you suggest can't work. It successfully works with ^ and !, but for all other characters it will add an unwanted ^ before the returned character if delayed expansion is enabled. The code I used was the simplest way to preserve all characters, including !, if delayed expansion happened to be enabled.<br /><br />But now that I know &lt;Ctrl-Z&gt; is preserved on Win 7, I will probably ditch this version all together. I do not want the outcome to be version dependent.<br /><br /><br /><strong class="text-strong">Regarding your second suggestion for :getAnyKey</strong><br /><br />I need the FINDSTR /N to preserve all lines of output so that I can differentiate between &lt;Ctrl-Z&gt; and &lt;LF&gt; on Win 10.<br /><br />I plan to rewrite :getKey with code from :getAnyKey, and ditch :getAnykey. I will need to adapt :getMaskedInput as well. I am also thinking of making :getKey configurable so that you can choose what characters you want to return for [Enter] and [Alt-10].<br /><br /><br />Dave Benham</div>
			</div>
			<hr />
					<div class="post">
				<h3>Re: Read key presses via REPLACE - New functions :getKey, :getAnyKey, :getMaskedInput</h3>
				<div class="date">Posted: <strong>06 Sep 2016 17:44</strong></div>
				<div class="author">by <strong>jeb</strong></div>
				<div class="content">Hi Dave,<br /><br />I was not aware of the difference between Win10 and Win7 for the &lt;CTRL-Z&gt; key.<br /><br />Btw. You can create a &lt;NUL&gt; character by pressing &lt;CTRL-2&gt; (tested with Win7).<br />REPLACE outputs &lt;NUL&gt;&lt;CR&gt;&lt;LF&gt; for this.<br /><br /><br /><blockquote><div><cite>dbenham wrote:</cite>The modified IF code you suggest can't work. It successfully works with ^ and !, but for all other characters it will add an unwanted ^ before the returned character if delayed expansion is enabled. The code I used was the simplest way to preserve ! if delayed expansion happened to be enabled.</div></blockquote><br />Obviously <img class="smilies" src="images/smilies/icon_wink.gif" alt=":wink:" title="Wink" /> it works as expected, as the caret will always be removed by the appended exclamation mark.<br /><br />jeb</div>
			</div>
			<hr />
					<div class="post">
				<h3>Re: Read key presses via REPLACE - New functions :getKey, :getAnyKey, :getMaskedInput</h3>
				<div class="date">Posted: <strong>06 Sep 2016 17:59</strong></div>
				<div class="author">by <strong>dbenham</strong></div>
				<div class="content">Wow <img class="smilies" src="images/smilies/icon_eek.gif" alt=":shock:" title="Shocked" /> <br />Interesting find about &lt;Ctrl-2&gt; and Null. <br /><span style="color: #0000FF"><strong class="text-strong">EDIT - But FOR /F cannot capture the character, so I don't see a simple way to differentiate between &lt;NULL&gt; and &lt;LF&gt;. I believe I would need a temp file, and possibly the FC command</strong></span><br /><br />And Ugh, of course your code works, now that you spell it out.  <img class="smilies" src="images/smilies/icon_redface.gif" alt=":oops:" title="Embarassed" /> <br />I feel as though both of our IF statements are equally simple and elegant for the task at hand.<br /><br /><br />Dave Benham</div>
			</div>
			<hr />
			</div>

	<div id="page-footer" class="page-footer">
		<div class="page-number">All times are <span title="UTC-6">UTC-06:00</span><br />Page <strong>1</strong> of <strong>2</strong></div>
		<div class="copyright">Powered by phpBB&reg; Forum Software &copy; phpBB Limited<br />https://www.phpbb.com/</div>
	</div>
</div>

</body>

<!-- Mirrored from www.dostips.com/forum/viewtopic.php?f=3&t=7396&view=print by HTTrack Website Copier/3.x [XR&CO'2014], Fri, 19 Oct 2018 06:28:24 GMT -->
</html>
