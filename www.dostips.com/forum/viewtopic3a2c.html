<!DOCTYPE html>
<html dir="ltr" lang="en-gb">

<!-- Mirrored from www.dostips.com/forum/viewtopic.php?f=3&t=6081&view=print by HTTrack Website Copier/3.x [XR&CO'2014], Fri, 19 Oct 2018 05:00:10 GMT -->
<!-- Added by HTTrack --><meta http-equiv="content-type" content="text/html;charset=UTF-8" /><!-- /Added by HTTrack -->
<head>
<meta charset="utf-8" />
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="robots" content="noindex" />

<title>DosTips.com &bull; JREN.BAT v2.8 - Rename files/folders using regular expressions</title>

<link href="styles/AllanStyle-SUBSILVER/theme/print.css" rel="stylesheet">
</head>
<body id="phpbb">
<div id="wrap" class="wrap">
	<a id="top" class="top-anchor" accesskey="t"></a>

	<div id="page-header">
		<h1>DosTips.com</h1>
		<p>A Forum all about DOS Batch<br /><a href="index-2.html">https://www.dostips.com/forum/</a></p>

		<h2>JREN.BAT v2.8 - Rename files/folders using regular expressions</h2>
		<p><a href="viewtopic7124.html?f=3&amp;t=6081">https://www.dostips.com/forum/viewtopic.php?f=3&amp;t=6081</a></p>
	</div>

	<div id="page-body" class="page-body">
		<div class="page-number">Page <strong>1</strong> of <strong>4</strong></div>
					<div class="post">
				<h3>JREN.BAT v2.8 - Rename files/folders using regular expressions</h3>
				<div class="date">Posted: <strong>30 Nov 2014 20:22</strong></div>
				<div class="author">by <strong>dbenham</strong></div>
				<div class="content">This is the current version of JREN.BAT. See the subsequent posts in this thread for examples of usage and to follow the development history.<br>
<br>
JREN.BAT
<div class="codebox"><p>Code: <a href="#" onclick="selectCode(this); return false;">Select all</a></p><pre><code>@if (@X)==(@Y) @end /* Harmless hybrid line that begins a JScript comment
@goto :Batch

::JREN.BAT version 2.8 by Dave Benham
::
::  Release History:
::    2.8  2018-10-17: Updated links to Microsoft regex and replace docs
::                     Bug fix in ts() - tz:0 was not working
::    2.7  2016-12-15: Added /NKEEP option.
::    2.6  2016-07-10: Fixed bug in ts() offset computations when the before and
::                     after have different timezones due to daylight savings.
::                     Added olm: and old: options to the ts() function to allow
::                     the addition of months/years without changing the local hour.
::                     In other words, the computation compensates for changes in
::                     dayling savings conditions.
::    2.4  2015-07-15: Added /?? and /??TS() paged help options
::    2.3  2015-03-03: Ignore invalid characters if /LIST mode
::                     Bug fix - abort if invalid character with /T mode
::    2.2  2014-12-10: Bug fix - forgot to make the search regex global
::    2.1  2014-12-10: Additional dt: options for FileSystemObject timestamps
::    2.0  2014-12-07: New /LIST option.
::                     Added ts() function and /?ts() documentation
::                     Many new JScript functions for use with /J with /LIST
::                     Added GOTO at top to improve startup performance
::    1.1  2014-12-02: Options may be prefaced with / or -
::                     Corrected some documentation
::    1.0  2014-11-30: Initial release
::
::============ Documentation ===========
:::
:::JREN  Search  Replace  [/Option  [Value]]...
:::JREN  /?[REGEX|REPLACE|VERSION|TS()]
:::JREN  /??[ts()]
:::
:::  Rename files in the current directory by performing a regular expression
:::  search/replace on the old file name to generate the new file name.
:::  This includes read only, hidden, and system files.
:::
:::  Search  - By default, this is a case sensitive JScript (ECMA) regular
:::            expression expressed as a string. The search is applied globally
:::            to the entire file name.
:::
:::            JScript regex syntax documentation is available at
:::            http://msdn.microsoft.com/en-us/library/ae5bf541(v=vs.80).aspx
:::
:::  Replace - By default, this is the string to be used as a replacement for
:::            each found search expression. Full support is provided for
:::            substituion patterns available to the JScript replace method.
:::
:::            For example, $&amp; represents the portion of the source that matched
:::            the entire search pattern, $1 represents the first captured
:::            submatch, $2 the second captured submatch, etc. A $ literal
:::            can be escaped as $$.
:::
:::            An empty replacement string must be represented as "".
:::
:::            Replace substitution pattern syntax is fully documented at
:::            http://msdn.microsoft.com/en-US/library/efy6s3e6(v=vs.80).aspx
:::
:::  Options:  Behavior may be altered by appending one or more options.
:::  The option names are case insensitive, and may appear in any order
:::  after the Replace argument. Options may be prefaced with / or -
:::
:::      /D  - Rename Directories instead of files.
:::
:::      /FM FileOrFolderMask
:::
:::            Only rename files or folders that match any of the pattern(s)
:::            using standard wildcards. Multiple patterns are delimited by a
:::            pipe (|). Only complete name matches count.
:::
:::              * matches any 0 or more characters
:::              ? matches any 0 or 1 character except .
:::
:::      /FX FileOrFolderExclusion
:::
:::            Exclude files or folders that match any of the pattern(s)
:::            using standard wildcards. Multiple patterns are delimited by a
:::            pipe (|). Only complete name matches count.
:::
:::              * matches any 0 or more characters
:::              ? matches any 0 or 1 character except .
:::
:::      /I  - Ignore case when matching.
:::
:::      /J  - Treat Replace as a JScript expression.
:::            The following variables contain details about each match:
:::
:::              $0 = the substring that matched the Search
:::              $1 through $n = captured submatch strings
:::              $off = the offset where the match occurred
:::              $src = the original source string
:::
:::            The following are also available:
:::
:::              $n = An incrementing number for use in the name. The value
:::                   is reset to the /NBEG value for each directory.
:::                   It increases by the /NINC value for each renamed file.
:::                   The value may be zero padded to the width specified by
:::                   the /NPAD value.
:::
:::              lc(str)
:::
:::                 Convert str to lower case. Shorthand for str.toLowerCase().
:::
:::              uc(str)
:::
:::                 Convert str to upper case. Shorthand for str.toUpperCase().
:::
:::              lpad(string,pad)
:::
:::                 Used to left pad string str to a minimum length. If the
:::                 str already has length &gt;= the pad string length, then no
:::                 change is made. Otherwise it left pads the value with the
:::                 characters of the pad string to the length of pad.
:::
:::                 Examples:
:::                    lpad(15,'0000')    returns "0015"
:::                    lpad(15,'    ')    returns "  15"
:::                    lpad(19011,'0000') returns "19011"
:::
:::              rpad(string,pad)
:::
:::                 Used to right pad the string to a minimum length. If the
:::                 str already has length &gt;= the pad string length, then no
:::                 change is made. Otherwise it right pads the value with the
:::                 characters of the pad string to the length of pad.
:::
:::              ts( {option:value, option:value...} )
:::
:::                 Perform date/time computations and produce formatted
:::                 timestamps. This function can get the current date/and time,
:::                 or get the created/lastModified/lastAccessed timestamps for
:::                 the file being renamed, or parse a date/time from the name
:::                 of the file, or use a user specified value.
:::
:::                 Use JREN /?TS() to get help on the ts() function
:::
:::              attr( [offChar] )
:::
:::                 Lists the attributes of the file/folder. Set attributes are
:::                 listed in upper case and unset attributes are shown as the
:::                 offChar, or lower case. The listed attributes are:
:::                   R - Read Only
:::                   H - Hidden
:::                   S - System
:::                   A - Archive
:::                   L - Link or Shortcut
:::                   C - Compressed
:::
:::              size( [pad] )
:::
:::                 File/folder size, optionally left padded to the length of
:::                 the pad string.
:::
:::              type( [pad] )
:::
:::                 File/folder type, optionally right padded to the length of
:::                 the pad string.
:::
:::              name( [pad] )
:::
:::                 Name of the file/folder, optionally right padded to
:::                 the length of the pad string.
:::
:::              path( [pad] )
:::
:::                 Full Path of file/folder, optionally right padded to
:::                 the length of the pad string.
:::
:::              parent( [pad] )
:::
:::                 Path of the parent folder, optionally right padded to
:::                 the length of the pad string.
:::
:::              sName( [pad ])
:::
:::                 Short (8.3) name of the file/folder, optionally right padded
:::                 to the length of the pad string.
:::
:::              sPath( [pad] )
:::
:::                 Path of the file/folder using short (8.3) names, optionally
:::                 right padded to the length of the pad string.
:::
:::              sParent( [pad] )
:::
:::                 Path of the parent folder using short (8.3) names,
:::                 optionally right padded to the length of the pad string.
:::
:::      /L  - Convert names to Lower case. Entire names can be converted to
:::            lower case without any other changes by using empty strings ("")
:::            for both Search and Replace.
:::
:::      /LIST - List the Rename results only, without quotes, and without
:::            renaming anything. Invalid file name characters are ignored.
:::            The resulting "name" is always listed, even if no change.
:::
:::      /NBEG BeginValue
:::
:::            Specifies the initial $n value. The value will be reset for each
:::            folder unless the /NKEEP option is given. The value must be an
:::            integer &gt;= 0. The default value is 1.
:::
:::      /NINC IncrementValue
:::
:::            Specifies the amount $n is incremented after each rename.
:::            The value must be an integer &gt;=1. The default value is 1.
:::
:::      /NKEEP - Do not reset $n with each folder. Note that child folders
:::            are processed before parents, so a child folder will likely
:::            receive the initial /NBEG value.
:::
:::      /NPAD MinWidth
:::
:::            Specifies the minimum width for each $n value. If the $n value
:::            has fewer digits than MinWidth, then the value is zero padded
:::            on the left to achieve the MinWidth. The value must be &gt;= 1.
:::            The default value is 3.
:::
:::      /P RootPath
:::
:::            Specifies the path where the rename is to take place.
:::            The default of . represents the current directory.
:::            Wildcards are not allowed.
:::
:::      /PM PathMask
:::
:::            Only rename files or folders whose parent folder path matches
:::            any of the PathMask pattern(s) using augmented wildcards.
:::            Multiple patterns are delimited by a pipe (|). Only full path
:::            matches count.
:::
:::              /P:  matches the root path specified by option /P
:::              **   matches any 0 or more characters
:::              *    matches any 0 or more characters except \
:::              ?    matches any 0 or 1 character except . or \
:::
:::           This option is only useful if the /S option is used.
:::
:::      /PX PathExclusion
:::
:::            Exclude files or folders whose parent folder path matches any
:::            of the PathExclusion pattern(s) using augmented wildcards.
:::            Multiple patterns are delimited by a pipe (|). Only full path
:::            matches count.
:::
:::              /P:  matches the root path specified by option /P
:::              **   matches any 0 or more characters
:::              *    matches any 0 or more characters except \
:::              ?    matches any 0 or 1 character except . or \
:::
:::           This option is only useful if the /S option is used.
:::
:::      /Q  - Do not list the renamed files/folders (Quiet mode).
:::
:::      /RFM RegexFileOrFoldereMask
:::
:::            Only rename files or folders that match the regular expression,
:::            ignoring case. Partial name matches count.
:::
:::      /RFX RegexFileOrFolderExclusion
:::
:::            Exclude files or folders that match the regular Expression,
:::            ignoring case. Partial name matches count.
:::
:::      /RPM RegexPathMask
:::
:::            Only rename files or folders whose parent folder path matches the
:::            RegexPathMask regular expression, ignoring case. Partial path
:::            matches count. This option is really only useful if the /S
:::            option is used.
:::
:::      /RPX RegexPathExclusion
:::
:::            Exclude files or folders whose parent folder path matches the
:::            RegexPathExclusion regular expression, ignoring case. Partial
:::            path matches count. This option is really only useful if the
:::            /S option is used.
:::
:::      /S  - Recurse Subdirectories.
:::
:::      /T  - List the rename operations that would be attempted,
:::            but do not rename anything. (Test mode)
:::
:::      /U  - Convert names to Upper case. Entire names can be converted to
:::            upper case without any other changes by using empty strings ("")
:::            for both Search and Replace.
:::
:::  Help is available by supplying a single argument beginning with /?:
:::
:::      /?        - Writes this help documentation to stdout.
:::      /??       - Same as /? except uses MORE to provide pagination
:::
:::      /?REGEX   - Opens up Microsoft's JScript regular expression
:::                  documentation within your browser.
:::
:::      /?REPLACE - Opens up Microsoft's JScript REPLACE documentation
:::                  within your browser.
:::
:::      /?VERSION - Writes the JREN version number to stdout.
:::
:::      /?TS()    - Writes documentation for the ts() function to stdout.
:::      /??TS()   - Same as /??TS() except uses MORE for pagination.
:::
:::  JREN.BAT was written by Dave Benham, and originally posted at
:::  http://www.dostips.com/forum/viewtopic.php?f=3&amp;t=6081
:::
:: =============== ts() documentation ===============
::+
::+ts( [ { [option:value [,option:value]...] } ] )
::+  
::+  A JScript function that can performs date and time computations and return
::+  a formatted time string.
::+  
::+  The option object argument within curly braces is optional - if no argument
::+  is given, then it returns the current timestamp using compressed ISO 8601
::+  format with milliseconds and local time zone - YYYYMMDDThhmmss.fff+zzzz
::+  
::+    Examples:
::+      ts()  - Current date/time:  YYYYMMDDThhmmss.fff+zzzz
::+      ts({dt:'created',fmt:'{iso-dt}'})  - The file create date:  YYYY-MM-DD
::+      ts({od:-1,fmt:'{YYYY}_{MM}_{DD}'}) - Yesterday's date:  YYYY_MM_DD
::+  
::+  Option names are case sensitive. There are 5 types of options:
::+    1) Specify the base date          - dt:
::+    2) Specify date/time offsets      - oy: om: od: oh: on: os: of:
::+    3) Specify the output time zone   - tz:
::+    4) Specify the output format      - fmt:
::+    5) Configure the day-of-week and  - wkd: weekday: mth: month:
::+       month names for non-English
::+       users
::+
::+  Specify the base date and time
::+
::+    dt:  Value specifies the base date and time. Many formats supported:
::+
::+      Current local date/time
::+        - do not specify a dt: value
::+        - undefined value
::+        - empty string ''
::+
::+        Examples:
::+          dt:''
::+          dt:undefined
::+
::+      Milliseconds since 1970-01-01 00:00:00 UTC
::+        - NumericExpression (math OK)
::+        - NumericString (no math)
::+
::+        Examples:
::+          dt: 1391230800000          = January 1, 19970 00:00:00 UTC
::+          dt: 1391230000000+800000   = January 1, 19970 00:00:00 UTC
::+          dt:'1391230800000'         = January 1, 19970 00:00:00 UTC
::+          dt:'1391230000000+800000'  = error
::+
::+      String timestamp representation
::+        - Any string accepted by the JScript Date.Parse() method.
::+            See http://msdn.microsoft.com/en-us/library/k4w173wk(v=vs.84).aspx
::+
::+        Examples: All of the following represent Midnight on January 4, 2013
::+                  assuming local time zone is U.S Eastern Standard Time (EST)
::+
::+          dt:'1-4-2013'                  Defaults to local time zone
::+          dt:'January 4, 2013 EST'       Explicit Eastern Std Time (US)
::+          dt:'2013/1/4 -05'              Explicit Eastern Std Time (US)
::+          dt:'Jan 3 2013 23: CST'        Central Standard Time (US)
::+          dt:'2013 3 Jan 9:00 pm -0800'  Pacific Standard Time (US)
::+          dt:'01/04/2013 05:00:00 UTC'   Universal Coordinated Time
::+          dt:'1/4/2013 05:30 +0530'      India Standard Time
::+
::+      File timestamps to millisecond accuracy using WMI. Very slow, but
::+      locale agnostic. WMI call may not work on some older machines.
::+        - 'created'   = Creation date/time of the file
::+        - 'modified'  = Last Modified date/time of the file
::+        - 'accessed'  = Last Accessed date/time of the file
::+
::+        Example:
::+          dt:'created'  = creation date/time of the file to be renamed
::+
::+      File timestamps to second accuracy using FileSystemObject. Very fast,
::+      but locale dependent. May not parse properly for some countries.
::+        - 'fsoCreated'  = Creation date/time of the file
::+        - 'fsoModified' = Last Modified date/time of the file
::+        - 'fsoAccessed' = Last Accessed date/time of the file
::+
::+      Array with 2 to 7 numeric expressions (local time only)
::+        - [year,months,days,hours,minutes,seconds,milliseconds]
::+            year and months are required, the rest are optional
::+            Missing values are assumed to be 0
::+            Missing values are not allowed between specified values
::+            month 0 = January
::+            day 1 = First day of month, day 0 = Last day of prior month
::+
::+          Examples:
::+            dt:[2014,3,1,17,30,22,457]  = April 1, 2014, 17:30:22.457
::+            dt:[2014,0,1]               = January 1, 2014, 00:00:00
::+            dt:[2014,0]                 = December 31, 2013, 00:00:00
::+            dt:[2014,,10]               = error
::+
::+  Date/Time offsets and time zone options all use the same syntax.
::+  The value represents a numeric offset for the specified time unit.
::+  It may be expressed as a numeric expression (math allowed), or
::+  a numeric string (no math allowed). Both positive and negative
::+  values may be used.
::+
::+    oy:  Year offset
::+    om:  Months offset
::+    od:  Days offset
::+    oh:  Hours offset
::+    on:  Minutes offset
::+    os:  Seconds offset
::+    of:  Milliseconds (Fractional seconds) offset
::+
::+    olm: LocalMonths offset (adjusted for changes in daylight savings)
::+    old: LocalDays offset (adjusted for changes in daylight savings)
::+
::+    tz:  Time zone used for output = minutes offset from UTC
::+
::+  The fmt: option is a string that specifies the format of the output.
::+  Strings within curly braces are replaced by dynamic components that are
::+  derived from the computed time stamp. Strings within braces that do not
::+  match a fmt: component are left as is. Strings not in braces are left
::+  as is. The format component names are not case senstive.
::+
::+  For example, a U.S. date would be represented as fmt:'{yyyy}/{mm}/{dd}'
::+
::+  The default format is '{ISOTS}', which yields YYYYMMDDThhmmss.fff+hhmm
::+
::+    {YYYY}  4 digit year, zero padded
::+
::+    {YY}    2 digit year, zero padded
::+
::+    {Y}     year without zero padding
::+
::+    {MONTH} month name
::+
::+    {MTH}   month abbreviation
::+
::+    {MM}    2 digit month, zero padded
::+
::+    {M}     month without zero padding
::+
::+    {WEEKDAY} day of week name
::+
::+    {WKD}   day of week abbreviation
::+
::+    {W}     day of week number, 0=Sunday
::+
::+    {DD}    2 digit day, zero padded
::+
::+    {D}     day without zero padding
::+
::+    {HH}    2 digit hours, 24 hour format, zero padded
::+
::+    {H}     hours, 24 hour format without zero padding
::+
::+    {HH12}  2 digit hours, 12 hour format, zero padded
::+
::+    {H12}   hours, 12 hour format without zero padding
::+
::+    {NN}    2 digit minutes, zero padded
::+
::+    {N}     minutes without padding
::+
::+    {SS}    2 digit seconds, zero padded
::+
::+    {S}     seconds without padding
::+
::+    {FFF}   3 digit milliseconds, zero padded
::+
::+    {F}     milliseconds without padding
::+
::+    {AM}    AM or PM in upper case
::+
::+    {PM}    am or pm in lower case
::+
::+    {ZZZZ}  timezone expressed as minutes offset from UTC,
::+            zero padded to 3 digits with sign
::+
::+    {Z}     timzone minutes offset from UTC without padding
::+
::+    {ZS}    timezone sign
::+
::+    {ZH}    timezone hours hours offset from UTC, (no sign),
::+            padded to 2 digits
::+
::+    {ZM}    timezone minutes offset from UTC (no sign),
::+            padded to 2 digits
::+
::+    {ISOTS} YYYYMMDDThhmmss.fff+hhss
::+            Compressed ISO 8601 date/time (timestamp) with milliseconds
::+            and time zone
::+
::+    {ISODT} YYYYMMDD
::+            Compressed ISO 8601 date format
::+
::+    {ISOTM} hhmmss.fff
::+            Compressed ISO 8601 time format with milliseconds
::+
::+    {ISOTZ} +hhmm
::+            Compressed ISO 8601 timezone format
::+
::+    {ISO-TS} YYYY-MM-DDThh:mm:ss.fff+hh:ss
::+             ISO 8601 date/time (timestamp) with milliseconds and time zone
::+
::+    {ISO-DT} YYYY-MM-DD
::+             ISO 8601 date format
::+
::+    {ISO-TM} hh:mm:ss.fff
::+             ISO 8601 time format with milliseconds
::+
::+    {ISO-TZ} +hh:mm
::+             ISO 8601 timezone
::+
::+    {U}     Unix Epoch time: same as {US}
::+            Seconds since 1970-01-01 00:00:00 UTC.
::+            Negative numbers represent dates prior to 1970-01-01.
::+            This value should not be used with the -TZ option
::+
::+    {UMS}   Milliseconds since 1970-01-01 00:00:00.000 UTC.
::+            Negative numbers represent days prior to 1970-01-01.
::+            This value should not be used with the -TZ option
::+
::+    {US}    Seconds since 1970-01-01 00:00:00.000 UTC.
::+            Negative numbers represent days prior to 1970-01-01.
::+            This value should not be used with the -TZ option
::+
::+    {UM}    Minutes since 1970-01-01 00:00:00.000 UTC.
::+            Negative numbers represent days prior to 1970-01-01.
::+            This value should not be used with the -TZ option
::+
::+    {UH}    Hours since 1970-01-01 00:00:00.000 UTC.
::+            Negative numbers represent days prior to 1970-01-01.
::+            This value should not be used with the -TZ option
::+
::+    {UD}    Days since 1970-01-01 00:00:00.000 UTC.
::+            Negative numbers represent days prior to 1970-01-01.
::+            This value should not be used with the -TZ option
::+
::+    {USD}   Decimal seconds since 1970-01-01 00:00:00.000 UTC.
::+            Negative numbers represent days prior to 1970-01-01.
::+            This value should not be used with the -TZ option
::+
::+    {UMD}   Decimal minutes since 1970-01-01 00:00:00.000 UTC.
::+            Negative numbers represent days prior to 1970-01-01.
::+            This value should not be used with the -TZ option
::+
::+    {UHD}   Decimal hours since 1970-01-01 00:00:00.000 UTC.
::+            Negative numbers represent days prior to 1970-01-01.
::+            This value should not be used with the -TZ option
::+
::+    {UDD}   Decimal days since 1970-01-01 00:00:00.000 UTC.
::+            Negative numbers represent days prior to 1970-01-01.
::+            This value should not be used with the -TZ option
::+
::+    {{}     A { character
::+
::+  The following options override the default English names for the months
::+  and days of the week. The value for each option is a space delimited list
::+  of names or abbreviations.
::+
::+    wkd: Day of week abbreviations
::+         default = 'Sun Mon Tue Wed Thu Fri Sat'
::+
::+    weekday: Day of week names
::+         default = 'Sunday Monday Tuesday Wednesday Thursday Friday'
::+
::+    mth: Month abbreviations
::+         default = 'Jan Feb Mar Apr May Jun Jul Aug Sep Oct Nov Dec'
::+
::+    month: Month names
::+         default = 'January February March April May Jun July August'
::+                 + ' September October November December'
::+
============= :Batch portion ============
@echo off
setlocal disableDelayedExpansion

if .%2 equ . (
  set "test=%~1"
  setlocal enableDelayedExpansion
  if "!test:~0,1!" equ "-" set "test=/!test:~1!"
  if "!test!" equ "/?" (
    for /f "tokens=* delims=:" %%A in ('findstr "^:::" "%~f0"') do @echo(%%A
    exit /b 0
  ) else if "!test!" equ "/??" 2&gt;nul (
    (for /f "tokens=* delims=:" %%A in ('findstr "^:::" "%~f0"') do @echo(%%A)|more /e
    exit /b 0
  ) else if /i "!test!" equ "/?ts()" (
    for /f "tokens=* delims=:+" %%A in ('findstr "^::+" "%~f0"') do @echo(%%A
    exit /b 0
  ) else if /i "!test!" equ "/??ts()" 2&gt;nul (
    (for /f "tokens=* delims=:+" %%A in ('findstr "^::+" "%~f0"') do @echo(%%A)|more /e
    exit /b 0
  ) else if /i "!test!" equ "/?regex" (
    explorer "https://msdn.microsoft.com/en-us/library/ae5bf541.aspx"
    exit /b 0
  ) else if /i "!test!" equ "/?replace" (
    explorer "https://msdn.microsoft.com/en-US/library/efy6s3e6.aspx"
    exit /b 0
  ) else if /i "!test!" equ "/?version" (
    for /f "tokens=* delims=:" %%A in ('findstr "^::JREN\.BAT" "%~f0"') do @echo(%%A
    exit /b 0
  ) else (
    call :err "Insufficient arguments"
    exit /b 2
  )
)

:: Define options
set "options= /D: /FM:"" /FX:"" /I: /J: /L: /LIST: /NBEG:1 /NINC:1 /NKEEP: /NPAD:3 /P:. /PM:"" /PX:"" /RFM:"" /RFX:"" /RPM:"" /RPX:"" /Q: /S: /T: /U: "

:: Set default option values
for %%O in (%options%) do for /f "tokens=1,* delims=:" %%A in ("%%O") do set "%%A=%%~B"

:: Get options
:loop
if not "%~3"=="" (
  set "test=%~3"
  setlocal enableDelayedExpansion
  if "!test:~0,1!" equ "-" set "test=/!test:~1!"
  if "!test:~0,1!" neq "/" (
    call :err "Too many arguments"
    exit /b 2
  )
  for /f "delims=" %%A in ("!test!") do (
    set "test=!options:*%%A:=! "
    if "!test!"=="!options! " (
        endlocal
        call :err "Invalid option %~3"
        exit /b 2
    ) else if "!test:~0,1!"==" " (
        endlocal
        set "%%A=1"
        if /i "%%A" equ "/L" set "/U="
        if /i "%%A" equ "/U" set "/L="
    ) else (
        endlocal
        if %4. equ . (
          call :err "Missing %~3 value"
          exit /b 2
        )
        set "%%A=%~4"
        shift /3
    )
  )
  shift /3
  goto :loop
)

:: Execute
cscript //E:JScript //nologo "%~f0" %1 %2
exit /b %errorlevel%

:err
&gt;&amp;2 (
  echo ERROR: %~1
)
exit /b

************* JScript portion **********/
var $n
var _g=new Object();
try {

  _g.defineReplFunc=function() {
    eval(_g.replFunc);
  }

  _g.main=function() {

    function err( msg, rtn ) {
      WScript.StdErr.WriteLine(msg);
      if (rtn) WScript.Quit(rtn);
    }

    function BuildRegex( loc, regex, options ) {
      try {
        return regex ? new RegExp( regex, options ) : false;
      } catch(e) {
        err( 'Invalid '+loc+' regular expression: '+e.message, 1);
      }
    }

    function GetInt( loc, numStr, minVal ) {
      var n = parseInt( numStr );
      if (isNaN(n) || n&lt;minVal) {
        err( 'Error: Invalid '+loc+' value', 1 );
      }
      return n;
    }

    var env = WScript.CreateObject("WScript.Shell").Environment("Process"),
        fso = new ActiveXObject("Scripting.FileSystemObject");

    try {
      var root = fso.GetFolder( env('/P') );
    } catch(e) {
      err( 'Invalid /P path: '+e.message, 1 );
    }

    function MaskRepl($0) {
      switch ($0) {
        case '/P:':
        case '/p:': return root.Path.replace(/[.^$*+?()[{\\|]/g,"\\$&amp;");
        case '**':  return '.*';
        case '*':   return '[^\\\\]*';
        case '?':   return '[^\\\\.]?';
        default:    return '\\'+$0;
      }
    }

    var args=WScript.Arguments,
        search = BuildRegex( 'Search', args.Item(0), env('/I')?'gi':'g' ),
        replace=args.Item(1),
        rMask = BuildRegex( '/RFM', env('/RFM'), 'i' ),
        rExclude = BuildRegex( '/RFX', env('/RFX'), 'i' ),
        rPathMask = BuildRegex( '/RPM', env('/RPM'), 'i' ),
        rPathExclude = BuildRegex( '/RPX', env('/RPX'), 'i' ),
        regex = new RegExp("/P:|[*][*]|[*]|[?]|[.^$+()[{\\\\]","ig");
        mask = env('/FM') ? new RegExp( '^(?:' + env('/FM').replace(regex,MaskRepl) + ')$', 'i' ) : false;
        exclude = env('/FX') ? new RegExp( '^(?:' + env('/FX').replace(regex,MaskRepl) + ')$', 'i' ) : false;
        pathMask = env('/PM') ? new RegExp( '^(?:' + env('/PM').replace(regex,MaskRepl) + ')$', 'i' ) : false;
        pathExclude = env('/PX') ? new RegExp( '^(?:' + env('/PX').replace(regex,MaskRepl) + ')$', 'i' ) : false;
        upper = env('/U'),
        lower = env('/L'),
        recurse = env('/S'),
        jscript = env('/J'),
        list = env('/LIST'),
        beg = GetInt( '/NBEG', env('/NBEG'), 0 ),
        inc = GetInt( '/NINC', env('/NINC'), 1 ),
        pad = GetInt( '/NPAD', env('/NPAD'), 1 ),
        keep = env('/NKEEP'),
        padStr = Array( pad+1 ).join('0'),
        test = env('/T'),
        quiet = env('/Q');

    var num = beg;

    _g.dirs = env('/D');

    function ProcessFolder( folder ) {
      var i, a=[];
      if (!keep) eval('var num = beg');
      if (recurse || _g.dirs) {
        var folders = new Enumerator(folder.SubFolders);
        for( i=0 ; !folders.atEnd(); folders.moveNext()) {
          a[i++]=folders.item()
          if (recurse) ProcessFolder(folders.item());
        }
      }
      if ( (!pathMask || pathMask.test(folder.Path)) &amp;&amp;
           (!rPathMask || rPathMask.test(folder.Path)) &amp;&amp;
           (!pathExclude || !pathExclude.test(folder.Path)) &amp;&amp;
           (!rPathExclude || !rPathExclude.test(folder.Path)) ) {
        if (!_g.dirs) {
          a=[];
          var files = new Enumerator(folder.Files);
          for (i=0; !files.atEnd(); files.moveNext()) a[i++]=files.item();
        }
        for (i=0; i&lt;a.length; i++) {
          _g.file = a[i];
          _g.wmiFile = undefined;
          var oldName = a[i].Name;
          if ( (!mask || mask.test(oldName)) &amp;&amp;
               (!rMask || rMask.test(oldName)) &amp;&amp;
               (!exclude || !exclude.test(oldName)) &amp;&amp;
               (!rExclude || !rExclude.test(oldName)) ) {
            if (jscript) {
              $n = num.toString();
              if ($n.length&lt;pad) $n = (padStr+$n).slice(-pad);
            }
            try {
              var newName = oldName.replace( search, replace );
            } catch(e) {
              err( 'Replace error: '+e.message, 1 );
            }
            if (!list) newName=newName.replace( /[ .]+$/, "" );
            if (jscript &amp;&amp; !list &amp;&amp; newName.search(/[&lt;&gt;|:/\\*?"\x00-\x1F]/)&gt;=0) err('Error: Invalid file name character in Replace',1);
            if (upper) newName = uc(newName);
            if (lower) newName = lc(newName);
            if (newName != oldName || list) {
              try {
                var oldPath=a[i].Path;
                if (!test &amp;&amp; !list) {
                  if (a[i].Name.toUpperCase() == newName.toUpperCase()) a[i].Name = '_{JREN_tempName}_';
                  a[i].Name = newName;
                }
                if (list) WScript.echo(newName);
                else if (!quiet) WScript.echo( '"'+oldPath+'"  --&gt;  "'+newName+'"' );
              } catch(e) {
                if (a[i].Name != oldName) a[i].Name = oldName;
                err( 'Unable to rename "'+a[i].Path+'"  --&gt;  "'+newName+'" : "'+e.message, 0 );
              }
              num+=inc;
            }
          }
        }
      }
    }

    if (jscript) {
      var regex=new RegExp('.|'+search,''),
          cnt;
      'x'.replace( regex, function(){cnt=arguments.length-2; return '';} );
      _g.replFunc='_g.replFunc=function($0';
      for (var i=1; i&lt;cnt; i++) _g.replFunc+=',$'+i;
      _g.replFunc+=',$off,$src){return eval(_g.replace);}';
      _g.defineReplFunc();
      _g.replace = replace;
      replace = _g.replFunc;
    } else if (!list &amp;&amp; replace.search(/[&lt;&gt;|:/\\*?"\x00-\x1F]/)&gt;=0) err('Error: Invalid file name character in Replace',1);

    ProcessFolder( root );
    WScript.Quit(0);
  }

  _g.main();

} catch(e) {
  WScript.StdErr.WriteLine("JScript runtime error: "+e.message);
  WScript.Quit(1);
}

function lc(str) { return str.toLowerCase(); }

function uc(str) { return str.toUpperCase(); }

function lpad( val, pad ) {
  if (!pad) pad='';
  var rtn=val.toString();
  return (rtn.length&lt;pad.length) ? (pad+rtn).slice(-pad.length) : val;
}

function rpad( val, pad ) {
  if (!pad) pad='';
  var rtn=val.toString();
  return (rtn.length&lt;pad.length) ? (rtn+pad).slice(0,pad.length) : val;
}

function ts(opt) {
  if (opt===undefined) opt={};
  if (opt.constructor !== Object) badOp('ts()');
  if (!opt.wkd)     opt.wkd='Sun Mon Tue Wed Thu Fri Sat';
  if (!opt.weekday) opt.weekday='Sunday Monday Tuesday Wednesday Thursday Friday Saturday';
  if (!opt.mth)     opt.mth='Jan Feb Mar Apr May Jun Jul Aug Sep Oct Nov Dec';
  if (!opt.month)   opt.month='January February March April May June July August September October November December';
  if (!opt.fmt)     opt.fmt='{isots}';

  var wkd     = opt.wkd.split(' '),
      weekday = opt.weekday.split(' '),
      mth     = opt.mth.split(' '),
      month   = opt.month.split(' '),
      y,m,d,w,h,h12,n,s,f,u,z,zs,za, dt,
      sp=' ', ps='/', pc=':', pd='-', pp='.', p2='00', p3='000', p4='0000';
  if (wkd.length!=7)     badOp('wkd');
  if (weekday.length!=7) badOp('weekday');
  if (mth.length!=12)    badOp('mth');
  if (month.length!=12)  badOp('month');

  dt = getDt(opt.dt);
  if (opt.oy) dt.setUTCFullYear(     dt.getUTCFullYear()    +getNum('oy'));
  if (opt.om) dt.setUTCMonth(        dt.getUTCMonth()       +getNum('om'));
  if (opt.od) dt.setUTCDate(         dt.getUTCDate()        +getNum('od'));
  if (opt.oh) dt.setUTCHours(        dt.getUTCHours()       +getNum('oh'));
  if (opt.on) dt.setUTCMinutes(      dt.getUTCMinutes()     +getNum('on'));
  if (opt.os) dt.setUTCSeconds(      dt.getUTCSeconds()     +getNum('os'));
  if (opt.of) dt.setUTCMilliseconds( dt.getUTCMilliseconds()+getNum('of'));
  if (opt.tz!==undefined) dt.setUTCMinutes(      dt.getUTCMinutes()  +(z=getNum('tz')));

  if (opt.olm) dt.setMonth(        dt.getMonth()       +getNum('olm'));
  if (opt.old) dt.setDate(         dt.getDate()        +getNum('old'));

  y = opt.tz!==undefined ? dt.getUTCFullYear(): dt.getFullYear();
  m = opt.tz!==undefined ? dt.getUTCMonth()   : dt.getMonth();
  d = opt.tz!==undefined ? dt.getUTCDate()    : dt.getDate();
  w = opt.tz!==undefined ? dt.getUTCDay()     : dt.getDay();
  h = opt.tz!==undefined ? dt.getUTCHours()   : dt.getHours();
  n = opt.tz!==undefined ? dt.getUTCMinutes() : dt.getMinutes();
  s = opt.tz!==undefined ? dt.getUTCSeconds() : dt.getSeconds();
  f = opt.tz!==undefined ? dt.getUTCMilliseconds() : dt.getMilliseconds();
  u = dt.getTime();

  h12 = h%12;
  if (!h12) h12=12;

  if (opt.tz==undefined) z=-dt.getTimezoneOffset();
  zs = z&lt;0 ? '-' : '+';
  za = Math.abs(z);

  return opt.fmt.replace( /\{(.*?)\}/gi, repl );

  function getNum( v ) {
    var rtn = Number(opt[v]);
    if (isNaN(rtn-rtn)) badOp(v);
    return rtn;
  }

  function getDt( v ) {
    var dt, n;
    if (v===undefined) {
      dt = new Date();
    } else switch (v.constructor) {
      case Date:
      case Number:
        dt = new Date(v);
        break;
      case Array:
        try {dt=eval( 'new Date('+v.join(',')+')' )} catch(e){}
        break;
      case String:
        switch (v.toLowerCase()) {
          case '':         dt = new Date(); break;
          case 'created':  dt = getWmiDt('c'); break;
          case 'modified': dt = getWmiDt('m'); break;
          case 'accessed': dt = getWmiDt('a'); break;
          case 'fsocreated':  dt = new Date(_g.file.DateCreated); break;
          case 'fsomodified': dt = new Date(_g.file.DateLastModified); break;
          case 'fsoaccessed': dt = new Date(_g.file.DateLastAccessed); break;
          default:
            n=Number(v);
            if (isNaN(n-n)) dt = new Date(v);
            else            dt = new Date(n);
            break;
        }
        break;
    }
    if (isNaN(dt)) badOp('dt');
    return dt;
  }
 
  function badOp(option) {
    throw new Error('Invalid '+option+' value');
  }

  function trunc( n ) { return Math[n&gt;0?"floor":"ceil"](n); }
 
  function repl($0,$1) {
    switch ($1.toUpperCase()) {
      case 'YYYY' : return lpad(y,p4);
      case 'YY'   : return (p2+y.toString()).slice(-2);
      case 'Y'    : return y.toString();
      case 'MM'   : return lpad(m+1,p2);
      case 'M'    : return (m+1).toString();
      case 'DD'   : return lpad(d,p2);
      case 'D'    : return d.toString();
      case 'W'    : return w.toString();
      case 'HH'   : return lpad(h,p2);
      case 'H'    : return h.toString();
      case 'HH12' : return lpad(h12,p2);
      case 'H12'  : return h12.toString();
      case 'NN'   : return lpad(n,p2);
      case 'N'    : return n.toString();
      case 'SS'   : return lpad(s,p2);
      case 'S'    : return s.toString();
      case 'FFF'  : return lpad(f,p3);
      case 'F'    : return f.toString();
      case 'AM'   : return h&gt;=12 ? 'PM' : 'AM';
      case 'PM'   : return h&gt;=12 ? 'pm' : 'am';
      case 'UMS'  : return u.toString();
      case 'USD'  : return (u/1000).toString();
      case 'UMD'  : return (u/1000/60).toString();
      case 'UHD'  : return (u/1000/60/60).toString();
      case 'UDD'  : return (u/1000/60/60/24).toString();
      case 'U'    : return trunc(u/1000).toString();
      case 'US'   : return trunc(u/1000).toString();
      case 'UM'   : return trunc(u/1000/60).toString();
      case 'UH'   : return trunc(u/1000/60/60).toString();
      case 'UD'   : return trunc(u/1000/60/60/24).toString();
      case 'ZZZZ' : return zs+lpad(za,p3);
      case 'Z'    : return z.toString();
      case 'ZS'   : return zs;
      case 'ZH'   : return lpad(trunc(za/60),p2);
      case 'ZM'   : return lpad(za%60,p2);
      case 'ISOTS'  : return ''+lpad(y,p4)+lpad(m+1,p2)+lpad(d,p2)+'T'+lpad(h,p2)+lpad(n,p2)+lpad(s,p2)+pp+lpad(f,p3)+zs+lpad(trunc(za/60),p2)+lpad(za%60,p2);
      case 'ISODT'  : return ''+lpad(y,p4)+lpad(m+1,p2)+lpad(d,p2);
      case 'ISOTM'  : return ''+lpad(h,p2)+lpad(n,p2)+lpad(s,p2)+pp+lpad(f,p3);
      case 'ISOTZ'  : return ''+zs+lpad(trunc(za/60),p2)+lpad(za%60,p2);
      case 'ISO-TS' : return ''+lpad(y,p4)+pd+lpad(m+1,p2)+pd+lpad(d,p2)+'T'+lpad(h,p2)+pc+lpad(n,p2)+pc+lpad(s,p2)+pp+lpad(f,p3)+zs+lpad(trunc(za/60),p2)+pc+lpad(za%60,p2);
      case 'ISO-DT' : return ''+lpad(y,p4)+pd+lpad(m+1,p2)+pd+lpad(d,p2);
      case 'ISO-TM' : return ''+lpad(h,p2)+pc+lpad(n,p2)+pc+lpad(s,p2)+pp+lpad(f,p3);
      case 'ISO-TZ' : return ''+zs+lpad(trunc(za/60),p2)+pc+lpad(za%60,p2);
      case 'WEEKDAY': return weekday[w];
      case 'WKD'    : return wkd[w];
      case 'MONTH'  : return month[m];
      case 'MTH'    : return mth[m];
      case '{'      : return $1;
      default       : return $0;
    }
  }

  function getWmiDt( prop ) {
    if (_g.wmi===undefined) {
      var svcLoc = new ActiveXObject("WbemScripting.SWbemLocator");
      _g.wmi = svcLoc.ConnectServer(".", "root\\cimv2");
    }
    if (_g.wmiFile===undefined) {
      _g.wmiFile = new Enumerator(_g.wmi.ExecQuery(
                                    "Select * From "+(_g.dirs?"Win32_Directory":"Cim_DataFile")
                                     +" Where Name = '"+_g.file.Path.replace(/\\/g,"\\\\").replace(/'/g,"\\'")+"'"
                                  )).item();
    }
    var wmiDt;
    switch (prop.toLowerCase()) {
      case 'c': wmiDt=_g.wmiFile.CreationDate; break;
      case 'm': wmiDt=_g.wmiFile.LastModified; break;
      case 'a': wmiDt=_g.wmiFile.LastAccessed; break;
      default: return undefined;
    }
    var tz=Number(wmiDt.substr(22));
    var dt = new Date(     wmiDt.substr(0,4)+ps+wmiDt.substr(4,2)+ps+wmiDt.substr(6,2)
                       +sp+wmiDt.substr(8,2)+pc+wmiDt.substr(10,2)+pc+wmiDt.substr(12,2)
                       +sp+wmiDt.substr(21,1)+lpad(trunc(tz/60),p2)+lpad(tz%60,p2)
                     );
    dt.setMilliseconds(Number(wmiDt.substr(15,3)));
    return dt;
  }

}

function attr(off) {
  var a=_g.file.Attributes;
  var o=off?off.substr(0,1):'';
  return  (a&amp;1   ?'R':o?o:'r')  //Read only
         +(a&amp;2   ?'H':o?o:'h')  //Hidden
         +(a&amp;4   ?'S':o?o:'s')  //System
         +(a&amp;32  ?'A':o?o:'a')  //Archive
         +(a&amp;1024?'L':o?o:'l')  //Link or Shortcut
         +(a&amp;2048?'C':o?o:'c'); //Compressed
}

function size(pad) {return lpad(_g.file.Size,pad);}

function type(pad) {return rpad(_g.file.Type,pad);}

function path(pad) {return rpad(_g.file.Path,pad);}

function parent(pad) {return rpad(_g.file.ParentFolder.Path,pad);}

function name(pad) {return rpad(_g.file.Name,pad);}

function sPath(pad) {return rpad(_g.file.ShortPath,pad);}

function sParent(pad) {return rpad(_g.file.ParentFolder.ShortPath,pad);}

function sName(pad) {return rpad(_g.file.ShortName,pad);}
</code></pre></div></div>
			</div>
			<hr />
					<div class="post">
				<h3>Re: JREN.BAT - Rename files/folders using regular expression</h3>
				<div class="date">Posted: <strong>30 Nov 2014 20:34</strong></div>
				<div class="author">by <strong>dbenham</strong></div>
				<div class="content">JREN.BAT is a hybrid JScript/batch utility that renames files or folders by performing a regular expression search and replace on the names. The utility is pure script that will run natively on any Windows machine from XP forward.<br /><br />Use <strong class="text-strong">JREN /?</strong> to get help from the command line.<br /><br /><em class="text-italics"><strong class="text-strong">Important Note:</strong></em> It is a good idea to initially use the /T (test) option when developing a JREN command. This will print out the rename operations that would be attempted, without actually renaming anything.<br /><br />Below are a few examples of usage. Often there are multiple ways to achieve the same result.<br /><br /><strong class="text-strong">1) Convert all .txt files to lower case in the current directory:</strong><br /><br />Using the search regular expression and the /L (lower case) and /I (ignore case) options<br /><div class="codebox"><p>Code: <a href="#" onclick="selectCode(this); return false;">Select all</a></p><pre><code>jren &quot;.*\.txt$&quot; &quot;$&amp;&quot; /l /i<br /></code></pre></div><br />Using the search regular expression and the /J (JScript expression) and /I options<br /><div class="codebox"><p>Code: <a href="#" onclick="selectCode(this); return false;">Select all</a></p><pre><code>jren &quot;.*\.txt$&quot; &quot;lc($0)&quot; /j /i<br /></code></pre></div><br />Using the /FM (file mask) and /L options<br /><div class="codebox"><p>Code: <a href="#" onclick="selectCode(this); return false;">Select all</a></p><pre><code>jren &quot;&quot; &quot;&quot; /l /fm &quot;*.txt&quot;<br /></code></pre></div><br />Using the /RFM (regular expression file mask) and /L options<br /><div class="codebox"><p>Code: <a href="#" onclick="selectCode(this); return false;">Select all</a></p><pre><code>jren &quot;&quot; &quot;&quot; /l /rfm &quot;\.txt$&quot;<br /></code></pre></div><br /><br /><strong class="text-strong">2) Rename all 76 &quot;.jpg&quot; files in the &quot;C:\photos\Christmas 2014&quot; directory to an increasing padded number followed by a constant string. Assume the current directory is &quot;C:\photos&quot;. Resulting file names should look like &quot;01_Christmas2014.jpg&quot;, &quot;02_Christmas2014.jpg&quot;, etc.</strong><br /><br />Using the search regular expression and the /P (root Path), /NPAD ($n pad width), /J, and /I options<br /><div class="codebox"><p>Code: <a href="#" onclick="selectCode(this); return false;">Select all</a></p><pre><code>jren &quot;.*\.jpg$&quot; &quot;$n+'_Christmas2014.jpg'&quot; /p &quot;Christmas 2014&quot; /npad 2 /j /i<br /></code></pre></div><br />Using the /P, /NPAD, /J, and /FM options<br /><div class="codebox"><p>Code: <a href="#" onclick="selectCode(this); return false;">Select all</a></p><pre><code>jren &quot;^.*&quot; &quot;$n+'_Christmas2014.jpg'&quot; /p &quot;Christmas 2014&quot; /fm &quot;*.jpg&quot; /npad 2 /j<br /></code></pre></div><br />Using the /P, /NPAD, /J, and /RFM options<br /><div class="codebox"><p>Code: <a href="#" onclick="selectCode(this); return false;">Select all</a></p><pre><code>jren &quot;^.*&quot; &quot;$n+'_Christmas2014.jpg'&quot; /p &quot;Christmas 2014&quot; /rfm &quot;\.jpg$&quot; /npad 2 /j<br /></code></pre></div><br /><br /><strong class="text-strong">3) Rename folders, moving a numeric suffix to the front of the name, padded to 2 digits. Recursively apply this only to folders with &quot;test&quot; as a parent folder, except ignore folders under the root path of &quot;C:\someName\test&quot;. Assume the current directory is the root path where recursion starts.</strong><br /><br />starting folder hierarchy:<br /><div class="codebox"><p>Code: <a href="#" onclick="selectCode(this); return false;">Select all</a></p><pre><code>C:\someName\test<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; proj 1<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; someName 1<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; cat 1<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; dog 2<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; zebra 3<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; anotherName 2<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; test<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; car 1<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ignore<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; motorcycle 11<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; train 3<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; proj 2<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; test<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; eel 3<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; fish 2<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; turtle 1<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; test<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; baseball 1<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; basketball 2<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; football 3<br /></code></pre></div><br />desired result (default sort order swaps positions of folders)<br /><div class="codebox"><p>Code: <a href="#" onclick="selectCode(this); return false;">Select all</a></p><pre><code>C:\someName\test<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; proj 1<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; someName 1<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; cat 1<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; dog 2<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; zebra 3<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; anotherName 2<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; test<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 01 car<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 03 train<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 11 motorcycle<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ignore<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; proj 2<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; test<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 01 turtle<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 02 fish<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 03 eel<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; test<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 01 baseball<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 02 basketball<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 03 football<br /></code></pre></div><br />Using the /D (rename Directories), /S (recurse subdirectories), /PM (path mask), /PX (path exclusion), and /J options<br /><div class="codebox"><p>Code: <a href="#" onclick="selectCode(this); return false;">Select all</a></p><pre><code>&nbsp; jren &quot;(.*) (\d+)$&quot; &quot;lpad($2,'00')+' '+$1&quot; /j /d /s /pm &quot;**\test&quot; /px &quot;/p:&quot;<br /></code></pre></div><br />Using the /D, /S, /J and /RPM (regular expression Path Mask) options<br /><div class="codebox"><p>Code: <a href="#" onclick="selectCode(this); return false;">Select all</a></p><pre><code>&nbsp; jren &quot;(.*) (\d+)$&quot; &quot;lpad($2,'00')+' '+$1&quot; /j /d /s /rpm &quot;c:\\somename\\test.*\\test$&quot;<br /></code></pre></div><br /><br /><strong class="text-strong">4) Hack to recursively iterate files or folders using sophisticated filtering</strong><br /><br />When JREN renames a file, it lists the original full path in quotes, followed by --&gt;, followed by the new name in quotes. For example, using the example from 3), one line of output would look like:<br /><div class="codebox"><p>Code: <a href="#" onclick="selectCode(this); return false;">Select all</a></p><pre><code>&quot;C:\someName\test\test\baseball 1&quot; --&gt; &quot;001 baseball&quot;<br /></code></pre></div><br />It is fairly easy to add the /T option and process the result with FOR /F to selectively iterate files or folders. Using a Search that returns the entire name, and a Replace of &quot;&quot;, coupled with the /T option, would yield results like:<br /><div class="codebox"><p>Code: <a href="#" onclick="selectCode(this); return false;">Select all</a></p><pre><code>&quot;C:\someName\test\test\baseball 1&quot; --&gt; &quot;&quot;<br /></code></pre></div><br />Then you just need to add FOR /F with the weird delims syntax to set the delimiter to a quote:<br /><div class="codebox"><p>Code: <a href="#" onclick="selectCode(this); return false;">Select all</a></p><pre><code>&nbsp; @echo off<br />&nbsp; for /f delims^=^&quot; %%F in (<br />&nbsp; &nbsp; 'jren &quot;.* \d+$&quot; &quot;&quot; /t /d /s /pm &quot;/p:**\test&quot;<br />&nbsp; ) do echo %%F<br /></code></pre></div><br />yields:<br /><div class="codebox"><p>Code: <a href="#" onclick="selectCode(this); return false;">Select all</a></p><pre><code>C:\someName\test\proj 1\test\car 1<br />C:\someName\test\proj 1\test\motorcycle 11<br />C:\someName\test\proj 1\test\train 3<br />C:\someName\test\proj 2\test\eel 3<br />C:\someName\test\proj 2\test\fish 2<br />C:\someName\test\proj 2\test\turtle 1<br />C:\someName\test\test\baseball 1<br />C:\someName\test\test\basketball 2<br />C:\someName\test\test\football 3<br /></code></pre></div><br /><br /><br /><strong class="text-strong">Here is JREN.BAT version 1</strong><br /><div class="codebox"><p>Code: <a href="#" onclick="selectCode(this); return false;">Select all</a></p><pre><code>@if (@X)==(@Y) @end /* Harmless hybrid line that begins a JScript comment<br />::JREN.BAT version 1.0<br />::<br />::&nbsp; Release History:<br />::&nbsp; &nbsp; 2014-11-30 v1.0: Initial release<br />::<br />::************ Documentation ***********<br />:::<br />:::JREN&nbsp; Search&nbsp; Replace&nbsp; &#91;/Option&nbsp; &#91;Value&#93;&#93;...<br />:::JREN&nbsp; /?&#91;REGEX|REPLACE|VERSION&#93;<br />:::<br />:::&nbsp; Rename files in the current directory by performing a regular expression<br />:::&nbsp; search/replace on the old file name to generate the new file name.<br />:::&nbsp; This includes read only, hidden, and system files.<br />:::<br />:::&nbsp; Search&nbsp; - By default, this is a case sensitive JScript (ECMA) regular<br />:::&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; expression expressed as a string. The search is applied globally<br />:::&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; to the entire file name.<br />:::<br />:::&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; JScript regex syntax documentation is available at<br />:::&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; http://msdn.microsoft.com/en-us/library/ae5bf541(v=vs.80).aspx<br />:::<br />:::&nbsp; Replace - By default, this is the string to be used as a replacement for<br />:::&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; each found search expression. Full support is provided for<br />:::&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; substituion patterns available to the JScript replace method.<br />:::<br />:::&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; For example, $&amp; represents the portion of the source that matched<br />:::&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; the entire search pattern, $1 represents the first captured<br />:::&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; submatch, $2 the second captured submatch, etc. A $ literal<br />:::&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; can be escaped as $$.<br />:::<br />:::&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; An empty replacement string must be represented as &quot;&quot;.<br />:::<br />:::&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Replace substitution pattern syntax is fully documented at<br />:::&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; http://msdn.microsoft.com/en-US/library/efy6s3e6(v=vs.80).aspx<br />:::<br />:::&nbsp; Options:&nbsp; Behavior may be altered by appending one or more options.<br />:::&nbsp; The option names are case insensitive, and may appear in any order<br />:::&nbsp; after the Replace argument.<br />:::<br />:::&nbsp; &nbsp; &nbsp; /D&nbsp; - Rename Directories instead of files.<br />:::<br />:::&nbsp; &nbsp; &nbsp; /I&nbsp; - Ignore case when matching.<br />:::<br />:::&nbsp; &nbsp; &nbsp; /FM FileOrFolderMask<br />:::<br />:::&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Only rename files or folders that match any of the pattern(s)<br />:::&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; using standard wildcards. Multiple patterns are delimited by a<br />:::&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; pipe (|). Only complete name matches count.<br />:::<br />:::&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; * matches any 0 or more characters<br />:::&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ? matches any 0 or 1 character except .<br />:::<br />:::&nbsp; &nbsp; &nbsp; /FX FileOrFolderExclusion<br />:::<br />:::&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Exclude files or folders that match any of the pattern(s)<br />:::&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; using standard wildcards. Multiple patterns are delimited by a<br />:::&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; pipe (|). Only complete name matches count.<br />:::<br />:::&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; * matches any 0 or more characters<br />:::&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ? matches any 0 or 1 character except .<br />:::<br />:::&nbsp; &nbsp; &nbsp; /J&nbsp; - Treat Replace as a JScript expression.<br />:::&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; The following variables contain details about each match:<br />:::<br />:::&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; $0 = the substring that matched the Search<br />:::&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; $1 through $n = captured submatch strings<br />:::&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; $off = the offset where the match occurred<br />:::&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; $src = the original source string<br />:::<br />:::&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; The following are also available:<br />:::<br />:::&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; $n = An incrementing number for use in the name. The value<br />:::&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;is reset to the /NBEG value for each directory.<br />:::&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;It increases by the /NINC value for each renamed file.<br />:::&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;The value may be zero padded to the width specified by<br />:::&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;the /NPAD value.<br />:::<br />:::&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; lc(str)<br />:::<br />:::&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Convert str to lower case. Shorthand for str.toLowerCase().<br />:::<br />:::&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; uc(str)<br />:::<br />:::&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Convert str to upper case. Shorthand for str.toUpperCase().<br />:::<br />:::&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; lpad(string,pad)<br />:::<br />:::&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Used to left pad string str to a minimum length. If the<br />:::&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;str already has length &gt;= the pad string length, then no<br />:::&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;change is made. Otherwise it left pads the value with the<br />:::&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;characters of the pad string to the length of pad.<br />:::<br />:::&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Examples:<br />:::&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; lpad(15,'0000')&nbsp; &nbsp; returns &quot;0015&quot;<br />:::&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; lpad(15,'&nbsp; &nbsp; ')&nbsp; &nbsp; returns &quot;&nbsp; 15&quot;<br />:::&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; lpad(19011,'0000') returns &quot;19011&quot;<br />:::<br />:::&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; rpad(string,pad)<br />:::<br />:::&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Used to right pad string str to a minimum length. If the<br />:::&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;str already has length &gt;= the pad string length, then no<br />:::&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;change is made. Otherwise it right pads the value with the<br />:::&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;characters of the pad string to the length of pad.<br />:::<br />:::&nbsp; &nbsp; &nbsp; /L&nbsp; - Convert names to Lower case. Entire names can be converted to<br />:::&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; lower case without any other changes by using empty strings (&quot;&quot;)<br />:::&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; for both Search and Replace.<br />:::<br />:::&nbsp; &nbsp; &nbsp; /NBEG BeginValue<br />:::<br />:::&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Specifies the initial $n value for each directory. The value<br />:::&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; must be an integer &gt;= 0. The default value is 1.<br />:::<br />:::&nbsp; &nbsp; &nbsp; /NINC IncrementValue<br />:::<br />:::&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Specifies the amount $n is incremented after each rename.<br />:::&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; The value must be an integer &gt;=1. The default value is 1.<br />:::<br />:::&nbsp; &nbsp; &nbsp; /NPAD MinWidth<br />:::<br />:::&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Specifies the minimum width for each $n value. If the $n value<br />:::&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; has fewer digits than MinWidth, then the value is zero padded<br />:::&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; on the left to achieve the MinWidth. The value must be &gt;= 1.<br />:::&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; The default value is 3.<br />:::<br />:::&nbsp; &nbsp; &nbsp; /P RootPath<br />:::<br />:::&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Specifies the path where the rename is to take place.<br />:::&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; The default of . represents the current directory.<br />:::&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Wildcards are not allowed.<br />:::<br />:::&nbsp; &nbsp; &nbsp; /PM PathMask<br />:::<br />:::&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Only rename files or folders whose parent folder path matches<br />:::&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; any of the PathMask pattern(s) using augmented wildcards.<br />:::&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Multiple patterns are delimited by a pipe (|). Only full path<br />:::&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; matches count.<br />:::<br />:::&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; /P:&nbsp; matches the root path specified by option /P<br />:::&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; **&nbsp; &nbsp;matches any 0 or more characters<br />:::&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; *&nbsp; &nbsp; matches any 0 or more characters except \<br />:::&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ?&nbsp; &nbsp; matches any 0 or 1 character except . or \<br />:::<br />:::&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;This option is only useful if the /S option is used.<br />:::<br />:::&nbsp; &nbsp; &nbsp; /PX PathExclusion<br />:::<br />:::&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Exclude files or folders whose parent folder path matches any<br />:::&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; of the PathExclusion pattern(s) using augmented wildcards.<br />:::&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Multiple patterns are delimited by a pipe (|). Only full path<br />:::&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; matches count.<br />:::<br />:::&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; /P:&nbsp; matches the root path specified by option /P<br />:::&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; **&nbsp; &nbsp;matches any 0 or more characters<br />:::&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; *&nbsp; &nbsp; matches any 0 or more characters except \<br />:::&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ?&nbsp; &nbsp; matches any 0 or 1 character except . or \<br />:::<br />:::&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;This option is only useful if the /S option is used.<br />:::<br />:::&nbsp; &nbsp; &nbsp; /RFM RegexFileOrFoldereMask<br />:::<br />:::&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Only rename files or folders that match the regular expression,<br />:::&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ignoring case. Partial name matches count.<br />:::<br />:::&nbsp; &nbsp; &nbsp; /RFX RegexFileOrFolderExclusion<br />:::<br />:::&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Exclude files or folders that match the regular Expression,<br />:::&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ignoring case. Partial name matches count.<br />:::<br />:::&nbsp; &nbsp; &nbsp; /RPM RegexPathMask<br />:::<br />:::&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Only rename files or folders whose parent folder path matches the<br />:::&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; RegexPathMask regular expression, ignoring case. Partial path<br />:::&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; matches count. This option is really only useful if the /S<br />:::&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; option is used.<br />:::<br />:::&nbsp; &nbsp; &nbsp; /RPX RegexPathExclusion<br />:::<br />:::&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Exclude files or folders whose parent folder path matches the<br />:::&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; RegexPathExclusion regular expression, ignoring case. Partial<br />:::&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; path matches count. This option is really only useful if the<br />:::&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; /S option is used.<br />:::<br />:::&nbsp; &nbsp; &nbsp; /Q&nbsp; - Do not list the renamed files/folders (Quiet mode).<br />:::<br />:::&nbsp; &nbsp; &nbsp; /S&nbsp; - Recurse Subdirectories.<br />:::<br />:::&nbsp; &nbsp; &nbsp; /T&nbsp; - List the rename operations that would be attempted,<br />:::&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; but do not rename anything. (Test mode)<br />:::<br />:::&nbsp; &nbsp; &nbsp; /U&nbsp; - Convert names to Upper case. Entire names can be converted to<br />:::&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; upper case without any other changes by using empty strings (&quot;&quot;)<br />:::&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; for both Search and Replace.<br />:::<br />:::&nbsp; Help is available by supplying a single argument beginning with /?:<br />:::<br />:::&nbsp; &nbsp; &nbsp; /?&nbsp; &nbsp; &nbsp; &nbsp; - Writes this help documentation to stdout.<br />:::<br />:::&nbsp; &nbsp; &nbsp; /?REGEX&nbsp; &nbsp;- Opens up Microsoft's JScript regular expression<br />:::&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; documentation within your browser.<br />:::<br />:::&nbsp; &nbsp; &nbsp; /?REPLACE - Opens up Microsoft's JScript REPLACE documentation<br />:::&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; within your browser.<br />:::<br />:::&nbsp; &nbsp; &nbsp; /?VERSION - Writes the JREPL version number to stdout.<br />:::<br />:::&nbsp; JREN.BAT was written by Dave Benham, and originally posted at<br />:::&nbsp; http://www.dostips.com/forum/viewtopic.php?f=3&amp;t=6081<br />:::<br /><br />::************ Batch portion ***********<br />@echo off<br />setlocal disableDelayedExpansion<br /><br />if .%2 equ . (<br />&nbsp; if &quot;%~1&quot; equ &quot;/?&quot; (<br />&nbsp; &nbsp; for /f &quot;tokens=* delims=:&quot; %%A in ('findstr &quot;^:::&quot; &quot;%~f0&quot;') do @echo(%%A<br />&nbsp; &nbsp; exit /b 0<br />&nbsp; ) else if /i &quot;%~1&quot; equ &quot;/?regex&quot; (<br />&nbsp; &nbsp; explorer &quot;http://msdn.microsoft.com/en-us/library/ae5bf541(v=vs.80).aspx&quot;<br />&nbsp; &nbsp; exit /b 0<br />&nbsp; ) else if /i &quot;%~1&quot; equ &quot;/?replace&quot; (<br />&nbsp; &nbsp; explorer &quot;http://msdn.microsoft.com/en-US/library/efy6s3e6(v=vs.80).aspx&quot;<br />&nbsp; &nbsp; exit /b 0<br />&nbsp; ) else if /i &quot;%~1&quot; equ &quot;/?version&quot; (<br />&nbsp; &nbsp; for /f &quot;tokens=* delims=:&quot; %%A in ('findstr &quot;^::JREN\.BAT&quot; &quot;%~f0&quot;') do @echo(%%A<br />&nbsp; &nbsp; exit /b 0<br />&nbsp; ) else (<br />&nbsp; &nbsp; call :err &quot;Insufficient arguments&quot;<br />&nbsp; &nbsp; exit /b 2<br />&nbsp; )<br />)<br /><br />:: Define options<br />set &quot;options= /D: /FM:&quot;&quot; /FX:&quot;&quot; /G: /I: /J: /L: /NBEG:1 /NINC:1 /NPAD:3 /P:. /PM:&quot;&quot; /PX:&quot;&quot; /RFM:&quot;&quot; /RFX:&quot;&quot; /RPM:&quot;&quot; /RPX:&quot;&quot; /Q: /S: /T: /U: &quot;<br /><br />:: Set default option values<br />for %%O in (%options%) do for /f &quot;tokens=1,* delims=:&quot; %%A in (&quot;%%O&quot;) do set &quot;%%A=%%~B&quot;<br /><br />:: Get options<br />:loop<br />if not &quot;%~3&quot;==&quot;&quot; (<br />&nbsp; set &quot;test=%~3&quot;<br />&nbsp; setlocal enableDelayedExpansion<br />&nbsp; if &quot;!test:~0,1!&quot; neq &quot;/&quot; (<br />&nbsp; &nbsp; call :err &quot;Too many arguments&quot;<br />&nbsp; &nbsp; exit /b 2<br />&nbsp; )<br />&nbsp; set &quot;test=!options:*%~3:=! &quot;<br />&nbsp; if &quot;!test!&quot;==&quot;!options! &quot; (<br />&nbsp; &nbsp; &nbsp; endlocal<br />&nbsp; &nbsp; &nbsp; call :err &quot;Invalid option %~3&quot;<br />&nbsp; &nbsp; &nbsp; exit /b 2<br />&nbsp; ) else if &quot;!test:~0,1!&quot;==&quot; &quot; (<br />&nbsp; &nbsp; &nbsp; endlocal<br />&nbsp; &nbsp; &nbsp; set &quot;%~3=1&quot;<br />&nbsp; &nbsp; &nbsp; if /i &quot;%~3&quot; equ &quot;/L&quot; set &quot;/U=&quot;<br />&nbsp; &nbsp; &nbsp; if /i &quot;%~3&quot; equ &quot;/U&quot; set &quot;/L=&quot;<br />&nbsp; ) else (<br />&nbsp; &nbsp; &nbsp; endlocal<br />&nbsp; &nbsp; &nbsp; if %4. equ . (<br />&nbsp; &nbsp; &nbsp; &nbsp; call :err &quot;Missing %~3 value&quot;<br />&nbsp; &nbsp; &nbsp; &nbsp; exit /b 2<br />&nbsp; &nbsp; &nbsp; )<br />&nbsp; &nbsp; &nbsp; set &quot;%~3=%~4&quot;<br />&nbsp; &nbsp; &nbsp; shift /3<br />&nbsp; )<br />&nbsp; shift /3<br />&nbsp; goto :loop<br />)<br /><br />:: Execute<br />cscript //E:JScript //nologo &quot;%~f0&quot; %1 %2<br />exit /b %errorlevel%<br /><br />:err<br />&gt;&amp;2 (<br />&nbsp; echo ERROR: %~1<br />)<br />exit /b<br /><br />************* JScript portion **********/<br />var $n<br />var _g=new Object();<br />try {<br /><br />&nbsp; _g.defineReplFunc=function() {<br />&nbsp; &nbsp; eval(_g.replFunc);<br />&nbsp; }<br /><br />&nbsp; _g.main=function() {<br /><br />&nbsp; &nbsp; function err( msg, rtn ) {<br />&nbsp; &nbsp; &nbsp; WScript.StdErr.WriteLine(msg);<br />&nbsp; &nbsp; &nbsp; if (rtn) WScript.Quit(rtn);<br />&nbsp; &nbsp; }<br /><br />&nbsp; &nbsp; function BuildRegex( loc, regex, options ) {<br />&nbsp; &nbsp; &nbsp; try {<br />&nbsp; &nbsp; &nbsp; &nbsp; return regex ? new RegExp( regex, options ) : false;<br />&nbsp; &nbsp; &nbsp; } catch(e) {<br />&nbsp; &nbsp; &nbsp; &nbsp; err( 'Invalid '+loc+' regular expression: '+e.message, 1);<br />&nbsp; &nbsp; &nbsp; }<br />&nbsp; &nbsp; }<br /><br />&nbsp; &nbsp; function GetInt( loc, numStr, minVal ) {<br />&nbsp; &nbsp; &nbsp; var n = parseInt( numStr );<br />&nbsp; &nbsp; &nbsp; if (isNaN(n) || n&lt;minVal) {<br />&nbsp; &nbsp; &nbsp; &nbsp; err( 'Error: Invalid '+loc+' value', 1 );<br />&nbsp; &nbsp; &nbsp; }<br />&nbsp; &nbsp; &nbsp; return n;<br />&nbsp; &nbsp; }<br /><br />&nbsp; &nbsp; var env = WScript.CreateObject(&quot;WScript.Shell&quot;).Environment(&quot;Process&quot;),<br />&nbsp; &nbsp; &nbsp; &nbsp; fso = new ActiveXObject(&quot;Scripting.FileSystemObject&quot;);<br /><br />&nbsp; &nbsp; try {<br />&nbsp; &nbsp; &nbsp; var root = fso.GetFolder( env('/P') );<br />&nbsp; &nbsp; } catch(e) {<br />&nbsp; &nbsp; &nbsp; err( 'Invalid /P path: '+e.message, 1 );<br />&nbsp; &nbsp; }<br /><br />&nbsp; &nbsp; function MaskRepl($0) {<br />&nbsp; &nbsp; &nbsp; switch ($0) {<br />&nbsp; &nbsp; &nbsp; &nbsp; case '/P:':<br />&nbsp; &nbsp; &nbsp; &nbsp; case '/p:': return root.Path.replace(/&#91;.^$*+?()&#91;{\\|&#93;/g,&quot;\\$&amp;&quot;);<br />&nbsp; &nbsp; &nbsp; &nbsp; case '**':&nbsp; return '.*';<br />&nbsp; &nbsp; &nbsp; &nbsp; case '*':&nbsp; &nbsp;return '&#91;^\\\\&#93;*';<br />&nbsp; &nbsp; &nbsp; &nbsp; case '?':&nbsp; &nbsp;return '&#91;^\\\\.&#93;?';<br />&nbsp; &nbsp; &nbsp; &nbsp; default:&nbsp; &nbsp; return '\\'+$0;<br />&nbsp; &nbsp; &nbsp; }<br />&nbsp; &nbsp; }<br /><br />&nbsp; &nbsp; var args=WScript.Arguments,<br />&nbsp; &nbsp; &nbsp; &nbsp; search = BuildRegex( 'Search', args.Item(0), env('/G')?'g':'' + env('/I')?'i':'' ),<br />&nbsp; &nbsp; &nbsp; &nbsp; replace=args.Item(1),<br />&nbsp; &nbsp; &nbsp; &nbsp; rMask = BuildRegex( '/RFM', env('/RFM'), 'i' ),<br />&nbsp; &nbsp; &nbsp; &nbsp; rExclude = BuildRegex( '/RFX', env('/RFX'), 'i' ),<br />&nbsp; &nbsp; &nbsp; &nbsp; rPathMask = BuildRegex( '/RPM', env('/RPM'), 'i' ),<br />&nbsp; &nbsp; &nbsp; &nbsp; rPathExclude = BuildRegex( '/RPX', env('/RPX'), 'i' ),<br />&nbsp; &nbsp; &nbsp; &nbsp; regex = new RegExp(&quot;/P:|&#91;*&#93;&#91;*&#93;|&#91;*&#93;|&#91;?&#93;|&#91;.^$+()&#91;{\\\\&#93;&quot;,&quot;ig&quot;);<br />&nbsp; &nbsp; &nbsp; &nbsp; mask = env('/FM') ? new RegExp( '^(?:' + env('/FM').replace(regex,MaskRepl) + ')$', 'i' ) : false;<br />&nbsp; &nbsp; &nbsp; &nbsp; exclude = env('/FX') ? new RegExp( '^(?:' + env('/FX').replace(regex,MaskRepl) + ')$', 'i' ) : false;<br />&nbsp; &nbsp; &nbsp; &nbsp; pathMask = env('/PM') ? new RegExp( '^(?:' + env('/PM').replace(regex,MaskRepl) + ')$', 'i' ) : false;<br />&nbsp; &nbsp; &nbsp; &nbsp; pathExclude = env('/PX') ? new RegExp( '^(?:' + env('/PX').replace(regex,MaskRepl) + ')$', 'i' ) : false;<br />&nbsp; &nbsp; &nbsp; &nbsp; dirs = env('/D'),<br />&nbsp; &nbsp; &nbsp; &nbsp; upper = env('/U'),<br />&nbsp; &nbsp; &nbsp; &nbsp; lower = env('/L'),<br />&nbsp; &nbsp; &nbsp; &nbsp; recurse = env('/S'),<br />&nbsp; &nbsp; &nbsp; &nbsp; jscript = env('/J'),<br />&nbsp; &nbsp; &nbsp; &nbsp; beg = GetInt( '/NBEG', env('/NBEG'), 0 ),<br />&nbsp; &nbsp; &nbsp; &nbsp; inc = GetInt( '/NINC', env('/NINC'), 1 ),<br />&nbsp; &nbsp; &nbsp; &nbsp; pad = GetInt( '/NPAD', env('/NPAD'), 1 ),<br />&nbsp; &nbsp; &nbsp; &nbsp; padStr = Array( pad+1 ).join('0'),<br />&nbsp; &nbsp; &nbsp; &nbsp; test = env('/T'),<br />&nbsp; &nbsp; &nbsp; &nbsp; quiet = env('/Q');<br /><br />&nbsp; &nbsp; function ProcessFolder( folder ) {<br />&nbsp; &nbsp; &nbsp; var i, a=&#91;&#93;;<br />&nbsp; &nbsp; &nbsp; var num = beg;<br />&nbsp; &nbsp; &nbsp; if (recurse || dirs) {<br />&nbsp; &nbsp; &nbsp; &nbsp; var folders = new Enumerator(folder.SubFolders);<br />&nbsp; &nbsp; &nbsp; &nbsp; for( i=0 ; !folders.atEnd(); folders.moveNext()) {<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; a&#91;i++&#93;=folders.item()<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; if (recurse) ProcessFolder(folders.item());<br />&nbsp; &nbsp; &nbsp; &nbsp; }<br />&nbsp; &nbsp; &nbsp; }<br />&nbsp; &nbsp; &nbsp; if ( (!pathMask || pathMask.test(folder.Path)) &amp;&amp;<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;(!rPathMask || rPathMask.test(folder.Path)) &amp;&amp;<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;(!pathExclude || !pathExclude.test(folder.Path)) &amp;&amp;<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;(!rPathExclude || !rPathExclude.test(folder.Path)) ) {<br />&nbsp; &nbsp; &nbsp; &nbsp; if (!dirs) {<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; a=&#91;&#93;;<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; var files = new Enumerator(folder.Files);<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; for (i=0; !files.atEnd(); files.moveNext()) a&#91;i++&#93;=files.item();<br />&nbsp; &nbsp; &nbsp; &nbsp; }<br />&nbsp; &nbsp; &nbsp; &nbsp; for (i=0; i&lt;a.length; i++) {<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; var oldName = a&#91;i&#93;.Name;<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; if ( (!mask || mask.test(oldName)) &amp;&amp;<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;(!rMask || rMask.test(oldName)) &amp;&amp;<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;(!exclude || !exclude.test(oldName)) &amp;&amp;<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;(!rExclude || !rExclude.test(oldName)) ) {<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; if (jscript) {<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; $n = num.toString();<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; if ($n.length&lt;pad) $n = (padStr+$n).slice(-pad);<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; try {<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; var newName = oldName.replace( search, replace );<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; } catch(e) {<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; err( 'Replace error: '+e.message, 1 );<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; newName=newName.replace( /&#91; .&#93;+$/, &quot;&quot; );<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; if (jscript &amp;&amp; newName.search(/&#91;&lt;&gt;|:/\\*?&quot;\x00-\x1F&#93;/)&gt;=0) err('Error: Invalid file name character in Replace',1);<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; if (upper) newName = uc(newName);<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; if (lower) newName = lc(newName);<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; if (newName != oldName) {<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; try {<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; var oldPath=a&#91;i&#93;.Path;<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; if (!test) {<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; if (a&#91;i&#93;.Name.toUpperCase() == newName.toUpperCase()) a&#91;i&#93;.Name = '_{JREN_tempName}_'<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; a&#91;i&#93;.Name = newName;<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; if (!quiet) WScript.echo( '&quot;'+oldPath+'&quot;&nbsp; --&gt;&nbsp; &quot;'+(test?newName:a&#91;i&#93;.Name)+'&quot;' );<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; } catch(e) {<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; err( 'Unable to rename &quot;'+a&#91;i&#93;.Path+'&quot;&nbsp; --&gt;&nbsp; &quot;'+newName+'&quot; : &quot;'+e.message, 0 );<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; num+=inc;<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br />&nbsp; &nbsp; &nbsp; &nbsp; }<br />&nbsp; &nbsp; &nbsp; }<br />&nbsp; &nbsp; }<br /><br />&nbsp; &nbsp; if (jscript) {<br />&nbsp; &nbsp; &nbsp; var regex=new RegExp('.|'+search,''),<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; cnt;<br />&nbsp; &nbsp; &nbsp; 'x'.replace( regex, function(){cnt=arguments.length-2; return '';} );<br />&nbsp; &nbsp; &nbsp; _g.replFunc='_g.replFunc=function($0';<br />&nbsp; &nbsp; &nbsp; for (var i=1; i&lt;cnt; i++) _g.replFunc+=',$'+i;<br />&nbsp; &nbsp; &nbsp; _g.replFunc+=',$off,$src){return eval(_g.replace);}';<br />&nbsp; &nbsp; &nbsp; _g.defineReplFunc();<br />&nbsp; &nbsp; &nbsp; _g.replace = replace;<br />&nbsp; &nbsp; &nbsp; replace = _g.replFunc;<br />&nbsp; &nbsp; } else if (replace.search(/&#91;&lt;&gt;|:/\\*?&quot;\x00-\x1F&#93;/)&gt;=0) err('Error: Invalid file name character in Replace',1);<br /><br />&nbsp; &nbsp; ProcessFolder( root );<br />&nbsp; &nbsp; WScript.Quit(0);<br />&nbsp; }<br /><br />&nbsp; _g.main();<br /><br />} catch(e) {<br />&nbsp; WScript.StdErr.WriteLine(&quot;JScript runtime error: &quot;+e.message);<br />&nbsp; WScript.Quit(1);<br />}<br /><br />function lc(str) { return str.toLowerCase(); }<br /><br />function uc(str) { return str.toUpperCase(); }<br /><br />function lpad( val, pad ) {<br />&nbsp; var rtn=val.toString();<br />&nbsp; return (rtn.length&lt;pad.length) ? (pad+rtn).slice(-pad.length) : val;<br />}<br /><br />function rpad( val, pad ) {<br />&nbsp; var rtn=val.toString();<br />&nbsp; return (rtn.length&lt;pad.length) ? (rtn+pad).slice(0,pad.length) : val;<br />}<br /></code></pre></div><br /><br />Dave Benham</div>
			</div>
			<hr />
					<div class="post">
				<h3>Re: JREN.BAT - Rename files/folders using regular expression</h3>
				<div class="date">Posted: <strong>30 Nov 2014 21:29</strong></div>
				<div class="author">by <strong>Squashman</strong></div>
				<div class="content">I am going to suggest to JJ Abrams that we name the new Star Wars movie: Star Wars Episode VII: Jscript Awakens.  <img class="smilies" src="images/smilies/icon_lol.gif" alt=":lol:" title="Laughing" /></div>
			</div>
			<hr />
					<div class="post">
				<h3>Re: JREN.BAT - Rename files/folders using regular expression</h3>
				<div class="date">Posted: <strong>30 Nov 2014 22:31</strong></div>
				<div class="author">by <strong>foxidrive</strong></div>
				<div class="content"><blockquote><div><cite>Squashman wrote:</cite>I am going to suggest to JJ Abrams that we name the new Star Wars movie: Star Wars Episode VII: Jscript Awakens.  <img class="smilies" src="images/smilies/icon_lol.gif" alt=":lol:" title="Laughing" /></div></blockquote><br /><br />ROFL! <img class="smilies" src="images/smilies/icon_biggrin.gif" alt=":D" title="Very Happy" /><br /><br /><blockquote><div><cite>dbenham wrote:</cite>JREN.BAT is a hybrid JScript/batch utility that renames files or folders by performing a regular expression search and replace on the names. The utility is pure script that will run natively on any Windows machine from XP forward.<br /></div></blockquote><br /><br />Nice Xmas present, Dave. <img class="smilies" src="images/smilies/icon_smile.gif" alt=":)" title="Smile" /></div>
			</div>
			<hr />
					<div class="post">
				<h3>Re: JREN.BAT - Rename files/folders using regular expression</h3>
				<div class="date">Posted: <strong>01 Dec 2014 07:18</strong></div>
				<div class="author">by <strong>brinda</strong></div>
				<div class="content">dave, thanks</div>
			</div>
			<hr />
					<div class="post">
				<h3>Re: JREN.BAT - Rename files/folders using regular expression</h3>
				<div class="date">Posted: <strong>02 Dec 2014 16:59</strong></div>
				<div class="author">by <strong>dbenham</strong></div>
				<div class="content">Minor release:<br /> - fix some documentation<br /> - Allow options as -Option or /Option<br /><br />JREN.BAT Version 1.1<br /><div class="codebox"><p>Code: <a href="#" onclick="selectCode(this); return false;">Select all</a></p><pre><code>@if (@X)==(@Y) @end /* Harmless hybrid line that begins a JScript comment<br />::JREN.BAT version 1.1<br />::<br />::&nbsp; Release History:<br />::&nbsp; &nbsp; 1.1&nbsp; 2014-12-02: Options may be prefaced with / or -<br />::&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Corrected some documentation<br />::&nbsp; &nbsp; 1.0&nbsp; 2014-11-30: Initial release<br />::<br />::************ Documentation ***********<br />:::<br />:::JREN&nbsp; Search&nbsp; Replace&nbsp; &#91;/Option&nbsp; &#91;Value&#93;&#93;...<br />:::JREN&nbsp; /?&#91;REGEX|REPLACE|VERSION&#93;<br />:::<br />:::&nbsp; Rename files in the current directory by performing a regular expression<br />:::&nbsp; search/replace on the old file name to generate the new file name.<br />:::&nbsp; This includes read only, hidden, and system files.<br />:::<br />:::&nbsp; Search&nbsp; - By default, this is a case sensitive JScript (ECMA) regular<br />:::&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; expression expressed as a string. The search is applied globally<br />:::&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; to the entire file name.<br />:::<br />:::&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; JScript regex syntax documentation is available at<br />:::&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; http://msdn.microsoft.com/en-us/library/ae5bf541(v=vs.80).aspx<br />:::<br />:::&nbsp; Replace - By default, this is the string to be used as a replacement for<br />:::&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; each found search expression. Full support is provided for<br />:::&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; substituion patterns available to the JScript replace method.<br />:::<br />:::&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; For example, $&amp; represents the portion of the source that matched<br />:::&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; the entire search pattern, $1 represents the first captured<br />:::&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; submatch, $2 the second captured submatch, etc. A $ literal<br />:::&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; can be escaped as $$.<br />:::<br />:::&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; An empty replacement string must be represented as &quot;&quot;.<br />:::<br />:::&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Replace substitution pattern syntax is fully documented at<br />:::&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; http://msdn.microsoft.com/en-US/library/efy6s3e6(v=vs.80).aspx<br />:::<br />:::&nbsp; Options:&nbsp; Behavior may be altered by appending one or more options.<br />:::&nbsp; The option names are case insensitive, and may appear in any order<br />:::&nbsp; after the Replace argument. Options may be prefaced with / or -<br />:::<br />:::&nbsp; &nbsp; &nbsp; /D&nbsp; - Rename Directories instead of files.<br />:::<br />:::&nbsp; &nbsp; &nbsp; /I&nbsp; - Ignore case when matching.<br />:::<br />:::&nbsp; &nbsp; &nbsp; /FM FileOrFolderMask<br />:::<br />:::&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Only rename files or folders that match any of the pattern(s)<br />:::&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; using standard wildcards. Multiple patterns are delimited by a<br />:::&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; pipe (|). Only complete name matches count.<br />:::<br />:::&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; * matches any 0 or more characters<br />:::&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ? matches any 0 or 1 character except .<br />:::<br />:::&nbsp; &nbsp; &nbsp; /FX FileOrFolderExclusion<br />:::<br />:::&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Exclude files or folders that match any of the pattern(s)<br />:::&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; using standard wildcards. Multiple patterns are delimited by a<br />:::&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; pipe (|). Only complete name matches count.<br />:::<br />:::&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; * matches any 0 or more characters<br />:::&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ? matches any 0 or 1 character except .<br />:::<br />:::&nbsp; &nbsp; &nbsp; /J&nbsp; - Treat Replace as a JScript expression.<br />:::&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; The following variables contain details about each match:<br />:::<br />:::&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; $0 = the substring that matched the Search<br />:::&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; $1 through $n = captured submatch strings<br />:::&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; $off = the offset where the match occurred<br />:::&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; $src = the original source string<br />:::<br />:::&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; The following are also available:<br />:::<br />:::&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; $n = An incrementing number for use in the name. The value<br />:::&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;is reset to the /NBEG value for each directory.<br />:::&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;It increases by the /NINC value for each renamed file.<br />:::&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;The value may be zero padded to the width specified by<br />:::&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;the /NPAD value.<br />:::<br />:::&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; lc(str)<br />:::<br />:::&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Convert str to lower case. Shorthand for str.toLowerCase().<br />:::<br />:::&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; uc(str)<br />:::<br />:::&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Convert str to upper case. Shorthand for str.toUpperCase().<br />:::<br />:::&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; lpad(string,pad)<br />:::<br />:::&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Used to left pad string str to a minimum length. If the<br />:::&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;str already has length &gt;= the pad string length, then no<br />:::&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;change is made. Otherwise it left pads the value with the<br />:::&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;characters of the pad string to the length of pad.<br />:::<br />:::&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Examples:<br />:::&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; lpad(15,'0000')&nbsp; &nbsp; returns &quot;0015&quot;<br />:::&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; lpad(15,'&nbsp; &nbsp; ')&nbsp; &nbsp; returns &quot;&nbsp; 15&quot;<br />:::&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; lpad(19011,'0000') returns &quot;19011&quot;<br />:::<br />:::&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; rpad(string,pad)<br />:::<br />:::&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Used to right pad string str to a minimum length. If the<br />:::&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;str already has length &gt;= the pad string length, then no<br />:::&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;change is made. Otherwise it right pads the value with the<br />:::&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;characters of the pad string to the length of pad.<br />:::<br />:::&nbsp; &nbsp; &nbsp; /L&nbsp; - Convert names to Lower case. Entire names can be converted to<br />:::&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; lower case without any other changes by using empty strings (&quot;&quot;)<br />:::&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; for both Search and Replace.<br />:::<br />:::&nbsp; &nbsp; &nbsp; /NBEG BeginValue<br />:::<br />:::&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Specifies the initial $n value for each directory. The value<br />:::&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; must be an integer &gt;= 0. The default value is 1.<br />:::<br />:::&nbsp; &nbsp; &nbsp; /NINC IncrementValue<br />:::<br />:::&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Specifies the amount $n is incremented after each rename.<br />:::&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; The value must be an integer &gt;=1. The default value is 1.<br />:::<br />:::&nbsp; &nbsp; &nbsp; /NPAD MinWidth<br />:::<br />:::&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Specifies the minimum width for each $n value. If the $n value<br />:::&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; has fewer digits than MinWidth, then the value is zero padded<br />:::&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; on the left to achieve the MinWidth. The value must be &gt;= 1.<br />:::&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; The default value is 3.<br />:::<br />:::&nbsp; &nbsp; &nbsp; /P RootPath<br />:::<br />:::&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Specifies the path where the rename is to take place.<br />:::&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; The default of . represents the current directory.<br />:::&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Wildcards are not allowed.<br />:::<br />:::&nbsp; &nbsp; &nbsp; /PM PathMask<br />:::<br />:::&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Only rename files or folders whose parent folder path matches<br />:::&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; any of the PathMask pattern(s) using augmented wildcards.<br />:::&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Multiple patterns are delimited by a pipe (|). Only full path<br />:::&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; matches count.<br />:::<br />:::&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; /P:&nbsp; matches the root path specified by option /P<br />:::&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; **&nbsp; &nbsp;matches any 0 or more characters<br />:::&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; *&nbsp; &nbsp; matches any 0 or more characters except \<br />:::&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ?&nbsp; &nbsp; matches any 0 or 1 character except . or \<br />:::<br />:::&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;This option is only useful if the /S option is used.<br />:::<br />:::&nbsp; &nbsp; &nbsp; /PX PathExclusion<br />:::<br />:::&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Exclude files or folders whose parent folder path matches any<br />:::&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; of the PathExclusion pattern(s) using augmented wildcards.<br />:::&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Multiple patterns are delimited by a pipe (|). Only full path<br />:::&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; matches count.<br />:::<br />:::&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; /P:&nbsp; matches the root path specified by option /P<br />:::&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; **&nbsp; &nbsp;matches any 0 or more characters<br />:::&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; *&nbsp; &nbsp; matches any 0 or more characters except \<br />:::&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ?&nbsp; &nbsp; matches any 0 or 1 character except . or \<br />:::<br />:::&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;This option is only useful if the /S option is used.<br />:::<br />:::&nbsp; &nbsp; &nbsp; /RFM RegexFileOrFoldereMask<br />:::<br />:::&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Only rename files or folders that match the regular expression,<br />:::&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ignoring case. Partial name matches count.<br />:::<br />:::&nbsp; &nbsp; &nbsp; /RFX RegexFileOrFolderExclusion<br />:::<br />:::&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Exclude files or folders that match the regular Expression,<br />:::&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ignoring case. Partial name matches count.<br />:::<br />:::&nbsp; &nbsp; &nbsp; /RPM RegexPathMask<br />:::<br />:::&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Only rename files or folders whose parent folder path matches the<br />:::&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; RegexPathMask regular expression, ignoring case. Partial path<br />:::&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; matches count. This option is really only useful if the /S<br />:::&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; option is used.<br />:::<br />:::&nbsp; &nbsp; &nbsp; /RPX RegexPathExclusion<br />:::<br />:::&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Exclude files or folders whose parent folder path matches the<br />:::&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; RegexPathExclusion regular expression, ignoring case. Partial<br />:::&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; path matches count. This option is really only useful if the<br />:::&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; /S option is used.<br />:::<br />:::&nbsp; &nbsp; &nbsp; /Q&nbsp; - Do not list the renamed files/folders (Quiet mode).<br />:::<br />:::&nbsp; &nbsp; &nbsp; /S&nbsp; - Recurse Subdirectories.<br />:::<br />:::&nbsp; &nbsp; &nbsp; /T&nbsp; - List the rename operations that would be attempted,<br />:::&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; but do not rename anything. (Test mode)<br />:::<br />:::&nbsp; &nbsp; &nbsp; /U&nbsp; - Convert names to Upper case. Entire names can be converted to<br />:::&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; upper case without any other changes by using empty strings (&quot;&quot;)<br />:::&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; for both Search and Replace.<br />:::<br />:::&nbsp; Help is available by supplying a single argument beginning with /?:<br />:::<br />:::&nbsp; &nbsp; &nbsp; /?&nbsp; &nbsp; &nbsp; &nbsp; - Writes this help documentation to stdout.<br />:::<br />:::&nbsp; &nbsp; &nbsp; /?REGEX&nbsp; &nbsp;- Opens up Microsoft's JScript regular expression<br />:::&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; documentation within your browser.<br />:::<br />:::&nbsp; &nbsp; &nbsp; /?REPLACE - Opens up Microsoft's JScript REPLACE documentation<br />:::&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; within your browser.<br />:::<br />:::&nbsp; &nbsp; &nbsp; /?VERSION - Writes the JREN version number to stdout.<br />:::<br />:::&nbsp; JREN.BAT was written by Dave Benham, and originally posted at<br />:::&nbsp; http://www.dostips.com/forum/viewtopic.php?f=3&amp;t=6081<br />:::<br /><br />::************ Batch portion ***********<br />@echo off<br />setlocal disableDelayedExpansion<br /><br />if .%2 equ . (<br />&nbsp; set &quot;test=%~1&quot;<br />&nbsp; setlocal enableDelayedExpansion<br />&nbsp; if &quot;!test:~0,1!&quot; equ &quot;-&quot; set &quot;test=/!test:~1!&quot;<br />&nbsp; if &quot;!test!&quot; equ &quot;/?&quot; (<br />&nbsp; &nbsp; for /f &quot;tokens=* delims=:&quot; %%A in ('findstr &quot;^:::&quot; &quot;%~f0&quot;') do @echo(%%A<br />&nbsp; &nbsp; exit /b 0<br />&nbsp; ) else if /i &quot;!test!&quot; equ &quot;/?regex&quot; (<br />&nbsp; &nbsp; explorer &quot;http://msdn.microsoft.com/en-us/library/ae5bf541(v=vs.80).aspx&quot;<br />&nbsp; &nbsp; exit /b 0<br />&nbsp; ) else if /i &quot;!test!&quot; equ &quot;/?replace&quot; (<br />&nbsp; &nbsp; explorer &quot;http://msdn.microsoft.com/en-US/library/efy6s3e6(v=vs.80).aspx&quot;<br />&nbsp; &nbsp; exit /b 0<br />&nbsp; ) else if /i &quot;!test!&quot; equ &quot;/?version&quot; (<br />&nbsp; &nbsp; for /f &quot;tokens=* delims=:&quot; %%A in ('findstr &quot;^::JREN\.BAT&quot; &quot;%~f0&quot;') do @echo(%%A<br />&nbsp; &nbsp; exit /b 0<br />&nbsp; ) else (<br />&nbsp; &nbsp; call :err &quot;Insufficient arguments&quot;<br />&nbsp; &nbsp; exit /b 2<br />&nbsp; )<br />)<br /><br />:: Define options<br />set &quot;options= /D: /FM:&quot;&quot; /FX:&quot;&quot; /G: /I: /J: /L: /NBEG:1 /NINC:1 /NPAD:3 /P:. /PM:&quot;&quot; /PX:&quot;&quot; /RFM:&quot;&quot; /RFX:&quot;&quot; /RPM:&quot;&quot; /RPX:&quot;&quot; /Q: /S: /T: /U: &quot;<br /><br />:: Set default option values<br />for %%O in (%options%) do for /f &quot;tokens=1,* delims=:&quot; %%A in (&quot;%%O&quot;) do set &quot;%%A=%%~B&quot;<br /><br />:: Get options<br />:loop<br />if not &quot;%~3&quot;==&quot;&quot; (<br />&nbsp; set &quot;test=%~3&quot;<br />&nbsp; setlocal enableDelayedExpansion<br />&nbsp; if &quot;!test:~0,1!&quot; equ &quot;-&quot; set &quot;test=/!test:~1!&quot;<br />&nbsp; if &quot;!test:~0,1!&quot; neq &quot;/&quot; (<br />&nbsp; &nbsp; call :err &quot;Too many arguments&quot;<br />&nbsp; &nbsp; exit /b 2<br />&nbsp; )<br />&nbsp; for /f &quot;delims=&quot; %%A in (&quot;!test!&quot;) do (<br />&nbsp; &nbsp; set &quot;test=!options:*%%A:=! &quot;<br />&nbsp; &nbsp; if &quot;!test!&quot;==&quot;!options! &quot; (<br />&nbsp; &nbsp; &nbsp; &nbsp; endlocal<br />&nbsp; &nbsp; &nbsp; &nbsp; call :err &quot;Invalid option %~3&quot;<br />&nbsp; &nbsp; &nbsp; &nbsp; exit /b 2<br />&nbsp; &nbsp; ) else if &quot;!test:~0,1!&quot;==&quot; &quot; (<br />&nbsp; &nbsp; &nbsp; &nbsp; endlocal<br />&nbsp; &nbsp; &nbsp; &nbsp; set &quot;%%A=1&quot;<br />&nbsp; &nbsp; &nbsp; &nbsp; if /i &quot;%%A&quot; equ &quot;/L&quot; set &quot;/U=&quot;<br />&nbsp; &nbsp; &nbsp; &nbsp; if /i &quot;%%A&quot; equ &quot;/U&quot; set &quot;/L=&quot;<br />&nbsp; &nbsp; ) else (<br />&nbsp; &nbsp; &nbsp; &nbsp; endlocal<br />&nbsp; &nbsp; &nbsp; &nbsp; if %4. equ . (<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; call :err &quot;Missing %~3 value&quot;<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; exit /b 2<br />&nbsp; &nbsp; &nbsp; &nbsp; )<br />&nbsp; &nbsp; &nbsp; &nbsp; set &quot;%%A=%~4&quot;<br />&nbsp; &nbsp; &nbsp; &nbsp; shift /3<br />&nbsp; &nbsp; )<br />&nbsp; )<br />&nbsp; shift /3<br />&nbsp; goto :loop<br />)<br /><br />:: Execute<br />cscript //E:JScript //nologo &quot;%~f0&quot; %1 %2<br />exit /b %errorlevel%<br /><br />:err<br />&gt;&amp;2 (<br />&nbsp; echo ERROR: %~1<br />)<br />exit /b<br /><br />************* JScript portion **********/<br />var $n<br />var _g=new Object();<br />try {<br /><br />&nbsp; _g.defineReplFunc=function() {<br />&nbsp; &nbsp; eval(_g.replFunc);<br />&nbsp; }<br /><br />&nbsp; _g.main=function() {<br /><br />&nbsp; &nbsp; function err( msg, rtn ) {<br />&nbsp; &nbsp; &nbsp; WScript.StdErr.WriteLine(msg);<br />&nbsp; &nbsp; &nbsp; if (rtn) WScript.Quit(rtn);<br />&nbsp; &nbsp; }<br /><br />&nbsp; &nbsp; function BuildRegex( loc, regex, options ) {<br />&nbsp; &nbsp; &nbsp; try {<br />&nbsp; &nbsp; &nbsp; &nbsp; return regex ? new RegExp( regex, options ) : false;<br />&nbsp; &nbsp; &nbsp; } catch(e) {<br />&nbsp; &nbsp; &nbsp; &nbsp; err( 'Invalid '+loc+' regular expression: '+e.message, 1);<br />&nbsp; &nbsp; &nbsp; }<br />&nbsp; &nbsp; }<br /><br />&nbsp; &nbsp; function GetInt( loc, numStr, minVal ) {<br />&nbsp; &nbsp; &nbsp; var n = parseInt( numStr );<br />&nbsp; &nbsp; &nbsp; if (isNaN(n) || n&lt;minVal) {<br />&nbsp; &nbsp; &nbsp; &nbsp; err( 'Error: Invalid '+loc+' value', 1 );<br />&nbsp; &nbsp; &nbsp; }<br />&nbsp; &nbsp; &nbsp; return n;<br />&nbsp; &nbsp; }<br /><br />&nbsp; &nbsp; var env = WScript.CreateObject(&quot;WScript.Shell&quot;).Environment(&quot;Process&quot;),<br />&nbsp; &nbsp; &nbsp; &nbsp; fso = new ActiveXObject(&quot;Scripting.FileSystemObject&quot;);<br /><br />&nbsp; &nbsp; try {<br />&nbsp; &nbsp; &nbsp; var root = fso.GetFolder( env('/P') );<br />&nbsp; &nbsp; } catch(e) {<br />&nbsp; &nbsp; &nbsp; err( 'Invalid /P path: '+e.message, 1 );<br />&nbsp; &nbsp; }<br /><br />&nbsp; &nbsp; function MaskRepl($0) {<br />&nbsp; &nbsp; &nbsp; switch ($0) {<br />&nbsp; &nbsp; &nbsp; &nbsp; case '/P:':<br />&nbsp; &nbsp; &nbsp; &nbsp; case '/p:': return root.Path.replace(/&#91;.^$*+?()&#91;{\\|&#93;/g,&quot;\\$&amp;&quot;);<br />&nbsp; &nbsp; &nbsp; &nbsp; case '**':&nbsp; return '.*';<br />&nbsp; &nbsp; &nbsp; &nbsp; case '*':&nbsp; &nbsp;return '&#91;^\\\\&#93;*';<br />&nbsp; &nbsp; &nbsp; &nbsp; case '?':&nbsp; &nbsp;return '&#91;^\\\\.&#93;?';<br />&nbsp; &nbsp; &nbsp; &nbsp; default:&nbsp; &nbsp; return '\\'+$0;<br />&nbsp; &nbsp; &nbsp; }<br />&nbsp; &nbsp; }<br /><br />&nbsp; &nbsp; var args=WScript.Arguments,<br />&nbsp; &nbsp; &nbsp; &nbsp; search = BuildRegex( 'Search', args.Item(0), env('/G')?'g':'' + env('/I')?'i':'' ),<br />&nbsp; &nbsp; &nbsp; &nbsp; replace=args.Item(1),<br />&nbsp; &nbsp; &nbsp; &nbsp; rMask = BuildRegex( '/RFM', env('/RFM'), 'i' ),<br />&nbsp; &nbsp; &nbsp; &nbsp; rExclude = BuildRegex( '/RFX', env('/RFX'), 'i' ),<br />&nbsp; &nbsp; &nbsp; &nbsp; rPathMask = BuildRegex( '/RPM', env('/RPM'), 'i' ),<br />&nbsp; &nbsp; &nbsp; &nbsp; rPathExclude = BuildRegex( '/RPX', env('/RPX'), 'i' ),<br />&nbsp; &nbsp; &nbsp; &nbsp; regex = new RegExp(&quot;/P:|&#91;*&#93;&#91;*&#93;|&#91;*&#93;|&#91;?&#93;|&#91;.^$+()&#91;{\\\\&#93;&quot;,&quot;ig&quot;);<br />&nbsp; &nbsp; &nbsp; &nbsp; mask = env('/FM') ? new RegExp( '^(?:' + env('/FM').replace(regex,MaskRepl) + ')$', 'i' ) : false;<br />&nbsp; &nbsp; &nbsp; &nbsp; exclude = env('/FX') ? new RegExp( '^(?:' + env('/FX').replace(regex,MaskRepl) + ')$', 'i' ) : false;<br />&nbsp; &nbsp; &nbsp; &nbsp; pathMask = env('/PM') ? new RegExp( '^(?:' + env('/PM').replace(regex,MaskRepl) + ')$', 'i' ) : false;<br />&nbsp; &nbsp; &nbsp; &nbsp; pathExclude = env('/PX') ? new RegExp( '^(?:' + env('/PX').replace(regex,MaskRepl) + ')$', 'i' ) : false;<br />&nbsp; &nbsp; &nbsp; &nbsp; dirs = env('/D'),<br />&nbsp; &nbsp; &nbsp; &nbsp; upper = env('/U'),<br />&nbsp; &nbsp; &nbsp; &nbsp; lower = env('/L'),<br />&nbsp; &nbsp; &nbsp; &nbsp; recurse = env('/S'),<br />&nbsp; &nbsp; &nbsp; &nbsp; jscript = env('/J'),<br />&nbsp; &nbsp; &nbsp; &nbsp; beg = GetInt( '/NBEG', env('/NBEG'), 0 ),<br />&nbsp; &nbsp; &nbsp; &nbsp; inc = GetInt( '/NINC', env('/NINC'), 1 ),<br />&nbsp; &nbsp; &nbsp; &nbsp; pad = GetInt( '/NPAD', env('/NPAD'), 1 ),<br />&nbsp; &nbsp; &nbsp; &nbsp; padStr = Array( pad+1 ).join('0'),<br />&nbsp; &nbsp; &nbsp; &nbsp; test = env('/T'),<br />&nbsp; &nbsp; &nbsp; &nbsp; quiet = env('/Q');<br /><br />&nbsp; &nbsp; function ProcessFolder( folder ) {<br />&nbsp; &nbsp; &nbsp; var i, a=&#91;&#93;;<br />&nbsp; &nbsp; &nbsp; var num = beg;<br />&nbsp; &nbsp; &nbsp; if (recurse || dirs) {<br />&nbsp; &nbsp; &nbsp; &nbsp; var folders = new Enumerator(folder.SubFolders);<br />&nbsp; &nbsp; &nbsp; &nbsp; for( i=0 ; !folders.atEnd(); folders.moveNext()) {<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; a&#91;i++&#93;=folders.item()<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; if (recurse) ProcessFolder(folders.item());<br />&nbsp; &nbsp; &nbsp; &nbsp; }<br />&nbsp; &nbsp; &nbsp; }<br />&nbsp; &nbsp; &nbsp; if ( (!pathMask || pathMask.test(folder.Path)) &amp;&amp;<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;(!rPathMask || rPathMask.test(folder.Path)) &amp;&amp;<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;(!pathExclude || !pathExclude.test(folder.Path)) &amp;&amp;<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;(!rPathExclude || !rPathExclude.test(folder.Path)) ) {<br />&nbsp; &nbsp; &nbsp; &nbsp; if (!dirs) {<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; a=&#91;&#93;;<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; var files = new Enumerator(folder.Files);<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; for (i=0; !files.atEnd(); files.moveNext()) a&#91;i++&#93;=files.item();<br />&nbsp; &nbsp; &nbsp; &nbsp; }<br />&nbsp; &nbsp; &nbsp; &nbsp; for (i=0; i&lt;a.length; i++) {<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; var oldName = a&#91;i&#93;.Name;<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; if ( (!mask || mask.test(oldName)) &amp;&amp;<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;(!rMask || rMask.test(oldName)) &amp;&amp;<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;(!exclude || !exclude.test(oldName)) &amp;&amp;<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;(!rExclude || !rExclude.test(oldName)) ) {<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; if (jscript) {<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; $n = num.toString();<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; if ($n.length&lt;pad) $n = (padStr+$n).slice(-pad);<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; try {<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; var newName = oldName.replace( search, replace );<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; } catch(e) {<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; err( 'Replace error: '+e.message, 1 );<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; newName=newName.replace( /&#91; .&#93;+$/, &quot;&quot; );<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; if (jscript &amp;&amp; newName.search(/&#91;&lt;&gt;|:/\\*?&quot;\x00-\x1F&#93;/)&gt;=0) err('Error: Invalid file name character in Replace',1);<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; if (upper) newName = uc(newName);<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; if (lower) newName = lc(newName);<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; if (newName != oldName) {<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; try {<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; var oldPath=a&#91;i&#93;.Path;<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; if (!test) {<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; if (a&#91;i&#93;.Name.toUpperCase() == newName.toUpperCase()) a&#91;i&#93;.Name = '_{JREN_tempName}_'<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; a&#91;i&#93;.Name = newName;<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; if (!quiet) WScript.echo( '&quot;'+oldPath+'&quot;&nbsp; --&gt;&nbsp; &quot;'+(test?newName:a&#91;i&#93;.Name)+'&quot;' );<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; } catch(e) {<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; err( 'Unable to rename &quot;'+a&#91;i&#93;.Path+'&quot;&nbsp; --&gt;&nbsp; &quot;'+newName+'&quot; : &quot;'+e.message, 0 );<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; num+=inc;<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br />&nbsp; &nbsp; &nbsp; &nbsp; }<br />&nbsp; &nbsp; &nbsp; }<br />&nbsp; &nbsp; }<br /><br />&nbsp; &nbsp; if (jscript) {<br />&nbsp; &nbsp; &nbsp; var regex=new RegExp('.|'+search,''),<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; cnt;<br />&nbsp; &nbsp; &nbsp; 'x'.replace( regex, function(){cnt=arguments.length-2; return '';} );<br />&nbsp; &nbsp; &nbsp; _g.replFunc='_g.replFunc=function($0';<br />&nbsp; &nbsp; &nbsp; for (var i=1; i&lt;cnt; i++) _g.replFunc+=',$'+i;<br />&nbsp; &nbsp; &nbsp; _g.replFunc+=',$off,$src){return eval(_g.replace);}';<br />&nbsp; &nbsp; &nbsp; _g.defineReplFunc();<br />&nbsp; &nbsp; &nbsp; _g.replace = replace;<br />&nbsp; &nbsp; &nbsp; replace = _g.replFunc;<br />&nbsp; &nbsp; } else if (replace.search(/&#91;&lt;&gt;|:/\\*?&quot;\x00-\x1F&#93;/)&gt;=0) err('Error: Invalid file name character in Replace',1);<br /><br />&nbsp; &nbsp; ProcessFolder( root );<br />&nbsp; &nbsp; WScript.Quit(0);<br />&nbsp; }<br /><br />&nbsp; _g.main();<br /><br />} catch(e) {<br />&nbsp; WScript.StdErr.WriteLine(&quot;JScript runtime error: &quot;+e.message);<br />&nbsp; WScript.Quit(1);<br />}<br /><br />function lc(str) { return str.toLowerCase(); }<br /><br />function uc(str) { return str.toUpperCase(); }<br /><br />function lpad( val, pad ) {<br />&nbsp; var rtn=val.toString();<br />&nbsp; return (rtn.length&lt;pad.length) ? (pad+rtn).slice(-pad.length) : val;<br />}<br /><br />function rpad( val, pad ) {<br />&nbsp; var rtn=val.toString();<br />&nbsp; return (rtn.length&lt;pad.length) ? (rtn+pad).slice(0,pad.length) : val;<br />}<br /></code></pre></div><br /><br />Dave Benham</div>
			</div>
			<hr />
					<div class="post">
				<h3>Re: JREN.BAT - Rename files/folders using regular expression</h3>
				<div class="date">Posted: <strong>07 Dec 2014 17:16</strong></div>
				<div class="author">by <strong>dbenham</strong></div>
				<div class="content"><strong class="text-strong"><span style="font-size: 150%; line-height: normal">Here are the new version 2 features:</span></strong><br /><br /><strong class="text-strong">1) Added ts( [ { [option:value  [,option:value]...] } ] )</strong><br /><br />JScript function for use with /J option that performs date/time computations and returns a formatted timestamp string. I basically adapted the code from my <a href="viewtopic5ecb.html?f=3&amp;t=4847" class="postlink">getTimestamp.bat utility</a>. Base dates can be derived from many sources:<br /><br /> - Parsed from the file/folder name<br /> - Any of the file/folder timestamps: created, last modified, last accessed<br /> - Today's date<br /> - Any date of your choosing, with many options for input format<br /><br />The ts() function has so many options, it needs its own dedicated help section <img class="smilies" src="images/smilies/icon_exclaim.gif" alt=":!:" title="Exclamation" /><br />There is a new help option to get ts() help:<br /><div class="codebox"><p>Code: <a href="#" onclick="selectCode(this); return false;">Select all</a></p><pre><code>JREN /?TS()<br /></code></pre></div><br /><strong class="text-strong">2) Added the /LIST option</strong><br /><br />Display the Replace result only, without quotes, and without renaming anything.<br />Useful for producing user formatted directory like listings.<br /><br /><strong class="text-strong">3) Added the following JScript functions for use with /LIST coupled with /J</strong><br /><br />File/folder attributes with optional left padding:<br /><div class="codebox"><p>Code: <a href="#" onclick="selectCode(this); return false;">Select all</a></p><pre><code>size( &#91;pad&#93; )&nbsp; &nbsp; - Size of file, or size of folder including subfolderrs<br /></code></pre></div><br />File/folder attributes with optional right padding:<br /><div class="codebox"><p>Code: <a href="#" onclick="selectCode(this); return false;">Select all</a></p><pre><code>&nbsp;attr( &#91;pad&#93; )&nbsp; &nbsp; - List of characters representing attributes: RHSALC<br />&nbsp;type( &#91;pad&#93; )&nbsp; &nbsp; - A description of what Windows thinks the file is<br />&nbsp;name( &#91;pad&#93; )&nbsp; &nbsp; - The name<br />&nbsp;path( &#91;pad&#93; )&nbsp; &nbsp; - Full path<br />&nbsp;parent( &#91;pad&#93; )&nbsp; - Full path of the parent folder<br />&nbsp;sName( &#91;pad&#93; )&nbsp; &nbsp;- Short 8.3 name<br />&nbsp;sPath( &#91;pad&#93; )&nbsp; &nbsp;- Full path using short 8.3 names<br />&nbsp;sParent( &#91;pad&#93; ) - Full path of the parent folder using short 8.3 names<br /></code></pre></div><br /><strong class="text-strong">4) Put a GOTO at the top to improve startup performance.</strong><br /><br />It took time for the batch processor to parse the extensive documentation, even though it does not get executed. The GOTO at the top skips the documentation, so startup times are noticeably faster.<br /><br /><br /><strong class="text-strong">Usage Examples:</strong><br /><br />Put the file creation timestamp at the beginning of all .txt file names<br /><div class="codebox"><p>Code: <a href="#" onclick="selectCode(this); return false;">Select all</a></p><pre><code>C:\test&gt;jren &quot;^&quot; &quot;ts({dt:'created',fmt:'{isots} '})&quot; /j /fm *.txt<br />&quot;C:\test\a+b.txt&quot;&nbsp; --&gt;&nbsp; &quot;20141130T121529.565-0500 a+b.txt&quot;<br />&quot;C:\test\jrepl.txt&quot;&nbsp; --&gt;&nbsp; &quot;20141114T082855.961-0500 jrepl.txt&quot;<br />&quot;C:\test\lib1.txt&quot;&nbsp; --&gt;&nbsp; &quot;20141125T195220.565-0500 lib1.txt&quot;<br />&quot;C:\test\lib2.txt&quot;&nbsp; --&gt;&nbsp; &quot;20141125T195248.845-0500 lib2.txt&quot;<br />&quot;C:\test\new.txt&quot;&nbsp; --&gt;&nbsp; &quot;20141119T233717.484-0500 new.txt&quot;<br />&quot;C:\test\old.txt&quot;&nbsp; --&gt;&nbsp; &quot;20141119T233614.131-0500 old.txt&quot;<br />&quot;C:\test\out.txt&quot;&nbsp; --&gt;&nbsp; &quot;20141108T162720.521-0500 out.txt&quot;<br />&quot;C:\test\test'it'.txt&quot;&nbsp; --&gt;&nbsp; &quot;20141126T140119.044-0500 test'it'.txt&quot;<br />&quot;C:\test\test(it).txt&quot;&nbsp; --&gt;&nbsp; &quot;20141126T144219.394-0500 test(it).txt&quot;<br />&quot;C:\test\test,it.txt&quot;&nbsp; --&gt;&nbsp; &quot;20141126T135759.083-0500 test,it.txt&quot;<br />&quot;C:\test\test.txt&quot;&nbsp; --&gt;&nbsp; &quot;20141112T084515.880-0500 test.txt&quot;<br />&quot;C:\test\test2.txt&quot;&nbsp; --&gt;&nbsp; &quot;20141114T173346.175-0500 test2.txt&quot;<br /></code></pre></div>The ISO format is great because it sorts chronologically, except for timestamps around the transition to or from daylight savings time. The timestamps always sort chronologically if you use UTC timestamps:<br /><div class="codebox"><p>Code: <a href="#" onclick="selectCode(this); return false;">Select all</a></p><pre><code>C:\test&gt;jren &quot;^&quot; &quot;ts({dt:'created',fmt:'{isodt}T{isotm}Z ',tz:0})&quot; /j /fm *.txt<br />&quot;C:\test\a+b.txt&quot;&nbsp; --&gt;&nbsp; &quot;20141130T171529.565Z a+b.txt&quot;<br />&quot;C:\test\jrepl.txt&quot;&nbsp; --&gt;&nbsp; &quot;20141114T132855.961Z jrepl.txt&quot;<br />&quot;C:\test\lib1.txt&quot;&nbsp; --&gt;&nbsp; &quot;20141126T005220.565Z lib1.txt&quot;<br />&quot;C:\test\lib2.txt&quot;&nbsp; --&gt;&nbsp; &quot;20141126T005248.845Z lib2.txt&quot;<br />&quot;C:\test\new.txt&quot;&nbsp; --&gt;&nbsp; &quot;20141120T043717.484Z new.txt&quot;<br />&quot;C:\test\old.txt&quot;&nbsp; --&gt;&nbsp; &quot;20141120T043614.131Z old.txt&quot;<br />&quot;C:\test\out.txt&quot;&nbsp; --&gt;&nbsp; &quot;20141108T212720.521Z out.txt&quot;<br />&quot;C:\test\test'it'.txt&quot;&nbsp; --&gt;&nbsp; &quot;20141126T190119.044Z test'it'.txt&quot;<br />&quot;C:\test\test(it).txt&quot;&nbsp; --&gt;&nbsp; &quot;20141126T194219.394Z test(it).txt&quot;<br />&quot;C:\test\test,it.txt&quot;&nbsp; --&gt;&nbsp; &quot;20141126T185759.083Z test,it.txt&quot;<br />&quot;C:\test\test.txt&quot;&nbsp; --&gt;&nbsp; &quot;20141112T134515.880Z test.txt&quot;<br />&quot;C:\test\test2.txt&quot;&nbsp; --&gt;&nbsp; &quot;20141114T223346.175Z test2.txt&quot;<br /></code></pre></div><br />Add yesterday's date to the end of each file name, immediately before the extension:<br /><div class="codebox"><p>Code: <a href="#" onclick="selectCode(this); return false;">Select all</a></p><pre><code>C:\test&gt;jren &quot;(\.txt)$&quot; &quot;' '+ts({od:-1,fmt:'{iso-dt}'})+$1&quot; /j /fm *.txt<br />&quot;C:\test\a+b.txt&quot;&nbsp; --&gt;&nbsp; &quot;a+b 2014-12-06.txt&quot;<br />&quot;C:\test\jrepl.txt&quot;&nbsp; --&gt;&nbsp; &quot;jrepl 2014-12-06.txt&quot;<br />&quot;C:\test\lib1.txt&quot;&nbsp; --&gt;&nbsp; &quot;lib1 2014-12-06.txt&quot;<br />&quot;C:\test\lib2.txt&quot;&nbsp; --&gt;&nbsp; &quot;lib2 2014-12-06.txt&quot;<br />&quot;C:\test\new.txt&quot;&nbsp; --&gt;&nbsp; &quot;new 2014-12-06.txt&quot;<br />&quot;C:\test\old.txt&quot;&nbsp; --&gt;&nbsp; &quot;old 2014-12-06.txt&quot;<br />&quot;C:\test\out.txt&quot;&nbsp; --&gt;&nbsp; &quot;out 2014-12-06.txt&quot;<br />&quot;C:\test\test'it'.txt&quot;&nbsp; --&gt;&nbsp; &quot;test'it' 2014-12-06.txt&quot;<br />&quot;C:\test\test(it).txt&quot;&nbsp; --&gt;&nbsp; &quot;test(it) 2014-12-06.txt&quot;<br />&quot;C:\test\test,it.txt&quot;&nbsp; --&gt;&nbsp; &quot;test,it 2014-12-06.txt&quot;<br />&quot;C:\test\test.txt&quot;&nbsp; --&gt;&nbsp; &quot;test 2014-12-06.txt&quot;<br />&quot;C:\test\test2.txt&quot;&nbsp; --&gt;&nbsp; &quot;test2 2014-12-06.txt&quot;<br /></code></pre></div><br />Taken from StackOverflow question: <a href="http://stackoverflow.com/questions/27217595/how-to-rename-files-moving-parts-of-filename-and-converting-date-format-with-b/27232846#27232846" class="postlink">How to rename files, moving parts of filename and converting date format, with batch?</a><br />old name: &quot;Some multiple word title Mon dd, yyyy - Some multiple word description.pdf&quot;<br />new name: &quot;yyyy-mm-dd - Some multiple word title - Some multiple word description.pdf&quot;<br /><div class="codebox"><p>Code: <a href="#" onclick="selectCode(this); return false;">Select all</a></p><pre><code>C:\test&gt;jren &quot;^(.* )(&#91;A-Z&#93;&#91;a-z&#93;{2} \d\d?, \d\d\d\d) -&quot; &quot;ts({dt:$2,fmt:'{iso-dt}'})+' - '+$1+'-'&quot; /j /fm *.pdf<br />&quot;C:\test\Another Title Oct 1, 2014 - 2nd Description blah blah.pdf&quot;&nbsp; --&gt;&nbsp; &quot;2014-10-01 - Another Title - 2nd Description blah blah.pdf&quot;<br />&quot;C:\test\Title Sep 29, 2014 - 2nd Description blah blah.pdf&quot;&nbsp; --&gt;&nbsp; &quot;2014-09-29 - Title - 2nd Description blah blah.pdf&quot;<br /></code></pre></div><br />Create a custom directory listing incorporating last modified timestamp with milliseconds, file attributes, and file size:<br /><div class="codebox"><p>Code: <a href="#" onclick="selectCode(this); return false;">Select all</a></p><pre><code>C:\test&gt;jren &quot;^.*&quot; &quot;ts({dt:'modified',fmt:'{iso-dt} {iso-tm} {iso-tz}&nbsp; '})+attr()+size('&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;')+'&nbsp; '+path()&quot; /j /list /fm *.bat<br />2014-11-20 20:22:26.743 -05:00&nbsp; rhsAlc&nbsp; &nbsp; 21989&nbsp; C:\test\findrepl.bat<br />2014-11-23 12:40:10.085 -05:00&nbsp; rhsAlc&nbsp; &nbsp; &nbsp; 230&nbsp; C:\test\jfindstr.bat<br />2014-11-08 22:23:10.443 -05:00&nbsp; rhsAlc&nbsp; &nbsp; &nbsp; &nbsp;33&nbsp; C:\test\lower.bat<br />2014-12-02 22:32:56.976 -05:00&nbsp; rhsAlc&nbsp; &nbsp; 15461&nbsp; C:\test\old.bat<br />2014-11-08 12:03:24.585 -05:00&nbsp; rhsAlc&nbsp; &nbsp; &nbsp; 290&nbsp; C:\test\pigLatin.bat<br />2014-11-29 17:12:21.173 -05:00&nbsp; rhsAlc&nbsp; &nbsp; &nbsp; &nbsp;20&nbsp; C:\test\test.bat<br />2014-11-02 13:54:47.882 -05:00&nbsp; rhsAlc&nbsp; &nbsp; &nbsp;1184&nbsp; C:\test\test01.bat<br />2014-11-29 13:15:01.108 -05:00&nbsp; rhsAlc&nbsp; &nbsp; &nbsp;1184&nbsp; C:\test\test02.bat<br />2014-11-08 22:21:57.994 -05:00&nbsp; rhsAlc&nbsp; &nbsp; &nbsp; &nbsp;33&nbsp; C:\test\upper.bat<br /></code></pre></div><br /><br />----------------------------------------------------------------------------------------------------<br /><br /><strong class="text-strong"><span style="font-size: 150%; line-height: normal">And here is the actual code.</span></strong><br /><br /><strong class="text-strong">JREN.BAT version 2.<span style="color: #0000BF">2</span></strong><br /><div class="codebox"><p>Code: <a href="#" onclick="selectCode(this); return false;">Select all</a></p><pre><code>@if (@X)==(@Y) @end /* Harmless hybrid line that begins a JScript comment<br />@goto :Batch<br /><br />::JREN.BAT version 2.2<br />::<br />::&nbsp; Release History:<br />::&nbsp; &nbsp; 2.2&nbsp; 2014-12-10: Bug fix - forgot to make the search regex global<br />::&nbsp; &nbsp; 2.1&nbsp; 2014-12-10: Additional dt: options for FileSystemObject timestamps<br />::&nbsp; &nbsp; 2.0&nbsp; 2014-12-07: New /LIST option.<br />::&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Added ts() function and /?ts() documentation<br />::&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Many new JScript functions for use with /J with /LIST<br />::&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Added GOTO at top to improve startup performance<br />::&nbsp; &nbsp; 1.1&nbsp; 2014-12-02: Options may be prefaced with / or -<br />::&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Corrected some documentation<br />::&nbsp; &nbsp; 1.0&nbsp; 2014-11-30: Initial release<br />::<br />::============ Documentation ===========<br />:::<br />:::JREN&nbsp; Search&nbsp; Replace&nbsp; &#91;/Option&nbsp; &#91;Value&#93;&#93;...<br />:::JREN&nbsp; /?&#91;REGEX|REPLACE|VERSION|TS()&#93;<br />:::<br />:::&nbsp; Rename files in the current directory by performing a regular expression<br />:::&nbsp; search/replace on the old file name to generate the new file name.<br />:::&nbsp; This includes read only, hidden, and system files.<br />:::<br />:::&nbsp; Search&nbsp; - By default, this is a case sensitive JScript (ECMA) regular<br />:::&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; expression expressed as a string. The search is applied globally<br />:::&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; to the entire file name.<br />:::<br />:::&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; JScript regex syntax documentation is available at<br />:::&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; http://msdn.microsoft.com/en-us/library/ae5bf541(v=vs.80).aspx<br />:::<br />:::&nbsp; Replace - By default, this is the string to be used as a replacement for<br />:::&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; each found search expression. Full support is provided for<br />:::&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; substituion patterns available to the JScript replace method.<br />:::<br />:::&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; For example, $&amp; represents the portion of the source that matched<br />:::&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; the entire search pattern, $1 represents the first captured<br />:::&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; submatch, $2 the second captured submatch, etc. A $ literal<br />:::&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; can be escaped as $$.<br />:::<br />:::&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; An empty replacement string must be represented as &quot;&quot;.<br />:::<br />:::&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Replace substitution pattern syntax is fully documented at<br />:::&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; http://msdn.microsoft.com/en-US/library/efy6s3e6(v=vs.80).aspx<br />:::<br />:::&nbsp; Options:&nbsp; Behavior may be altered by appending one or more options.<br />:::&nbsp; The option names are case insensitive, and may appear in any order<br />:::&nbsp; after the Replace argument. Options may be prefaced with / or -<br />:::<br />:::&nbsp; &nbsp; &nbsp; /D&nbsp; - Rename Directories instead of files.<br />:::<br />:::&nbsp; &nbsp; &nbsp; /I&nbsp; - Ignore case when matching.<br />:::<br />:::&nbsp; &nbsp; &nbsp; /FM FileOrFolderMask<br />:::<br />:::&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Only rename files or folders that match any of the pattern(s)<br />:::&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; using standard wildcards. Multiple patterns are delimited by a<br />:::&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; pipe (|). Only complete name matches count.<br />:::<br />:::&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; * matches any 0 or more characters<br />:::&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ? matches any 0 or 1 character except .<br />:::<br />:::&nbsp; &nbsp; &nbsp; /FX FileOrFolderExclusion<br />:::<br />:::&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Exclude files or folders that match any of the pattern(s)<br />:::&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; using standard wildcards. Multiple patterns are delimited by a<br />:::&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; pipe (|). Only complete name matches count.<br />:::<br />:::&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; * matches any 0 or more characters<br />:::&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ? matches any 0 or 1 character except .<br />:::<br />:::&nbsp; &nbsp; &nbsp; /J&nbsp; - Treat Replace as a JScript expression.<br />:::&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; The following variables contain details about each match:<br />:::<br />:::&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; $0 = the substring that matched the Search<br />:::&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; $1 through $n = captured submatch strings<br />:::&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; $off = the offset where the match occurred<br />:::&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; $src = the original source string<br />:::<br />:::&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; The following are also available:<br />:::<br />:::&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; $n = An incrementing number for use in the name. The value<br />:::&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;is reset to the /NBEG value for each directory.<br />:::&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;It increases by the /NINC value for each renamed file.<br />:::&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;The value may be zero padded to the width specified by<br />:::&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;the /NPAD value.<br />:::<br />:::&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; lc(str)<br />:::<br />:::&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Convert str to lower case. Shorthand for str.toLowerCase().<br />:::<br />:::&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; uc(str)<br />:::<br />:::&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Convert str to upper case. Shorthand for str.toUpperCase().<br />:::<br />:::&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; lpad(string,pad)<br />:::<br />:::&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Used to left pad string str to a minimum length. If the<br />:::&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;str already has length &gt;= the pad string length, then no<br />:::&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;change is made. Otherwise it left pads the value with the<br />:::&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;characters of the pad string to the length of pad.<br />:::<br />:::&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Examples:<br />:::&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; lpad(15,'0000')&nbsp; &nbsp; returns &quot;0015&quot;<br />:::&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; lpad(15,'&nbsp; &nbsp; ')&nbsp; &nbsp; returns &quot;&nbsp; 15&quot;<br />:::&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; lpad(19011,'0000') returns &quot;19011&quot;<br />:::<br />:::&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; rpad(string,pad)<br />:::<br />:::&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Used to right pad the string to a minimum length. If the<br />:::&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;str already has length &gt;= the pad string length, then no<br />:::&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;change is made. Otherwise it right pads the value with the<br />:::&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;characters of the pad string to the length of pad.<br />:::<br />:::&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ts( {option:value, option:value...} )<br />:::<br />:::&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Perform date/time computations and produce formatted<br />:::&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;timestamps. This function can get the current date/and time,<br />:::&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;or get the created/lastModified/lastAccessed timestamps for<br />:::&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;the file being renamed, or parse a date/time from the name<br />:::&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;of the file, or use a user specified value.<br />:::<br />:::&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Use JREN /?TS() to get help on the ts() function<br />:::<br />:::&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; attr( &#91;offChar&#93; )<br />:::<br />:::&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Lists the attributes of the file/folder. Set attributes are<br />:::&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;listed in upper case and unset attributes are shown as the<br />:::&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;offChar, or lower case. The listed attributes are:<br />:::&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;R - Read Only<br />:::&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;H - Hidden<br />:::&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;S - System<br />:::&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;A - Archive<br />:::&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;L - Link or Shortcut<br />:::&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;C - Compressed<br />:::<br />:::&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; size( &#91;pad&#93; )<br />:::<br />:::&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;File/folder size, optionally left padded to the length of<br />:::&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;the pad string.<br />:::<br />:::&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; type( &#91;pad&#93; )<br />:::<br />:::&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;File/folder type, optionally right padded to the length of<br />:::&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;the pad string.<br />:::<br />:::&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; name( &#91;pad&#93; )<br />:::<br />:::&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Name of the file/folder, optionally right padded to<br />:::&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;the length of the pad string.<br />:::<br />:::&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; path( &#91;pad&#93; )<br />:::<br />:::&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Full Path of file/folder, optionally right padded to<br />:::&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;the length of the pad string.<br />:::<br />:::&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; parent( &#91;pad&#93; )<br />:::<br />:::&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Path of the parent folder, optionally right padded to<br />:::&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;the length of the pad string.<br />:::<br />:::&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; sName( &#91;pad &#93;)<br />:::<br />:::&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Short (8.3) name of the file/folder, optionally right padded<br />:::&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;to the length of the pad string.<br />:::<br />:::&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; sPath( &#91;pad&#93; )<br />:::<br />:::&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Path of the file/folder using short (8.3) names, optionally<br />:::&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;right padded to the length of the pad string.<br />:::<br />:::&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; sParent( &#91;pad&#93; )<br />:::<br />:::&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Path of the parent folder using short (8.3) names,<br />:::&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;optionally right padded to the length of the pad string.<br />:::<br />:::&nbsp; &nbsp; &nbsp; /L&nbsp; - Convert names to Lower case. Entire names can be converted to<br />:::&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; lower case without any other changes by using empty strings (&quot;&quot;)<br />:::&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; for both Search and Replace.<br />:::<br />:::&nbsp; &nbsp; &nbsp; /LIST - List the Rename results only, without quotes, and without<br />:::&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; renaming anything.<br />:::<br />:::&nbsp; &nbsp; &nbsp; /NBEG BeginValue<br />:::<br />:::&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Specifies the initial $n value for each directory. The value<br />:::&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; must be an integer &gt;= 0. The default value is 1.<br />:::<br />:::&nbsp; &nbsp; &nbsp; /NINC IncrementValue<br />:::<br />:::&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Specifies the amount $n is incremented after each rename.<br />:::&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; The value must be an integer &gt;=1. The default value is 1.<br />:::<br />:::&nbsp; &nbsp; &nbsp; /NPAD MinWidth<br />:::<br />:::&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Specifies the minimum width for each $n value. If the $n value<br />:::&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; has fewer digits than MinWidth, then the value is zero padded<br />:::&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; on the left to achieve the MinWidth. The value must be &gt;= 1.<br />:::&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; The default value is 3.<br />:::<br />:::&nbsp; &nbsp; &nbsp; /P RootPath<br />:::<br />:::&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Specifies the path where the rename is to take place.<br />:::&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; The default of . represents the current directory.<br />:::&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Wildcards are not allowed.<br />:::<br />:::&nbsp; &nbsp; &nbsp; /PM PathMask<br />:::<br />:::&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Only rename files or folders whose parent folder path matches<br />:::&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; any of the PathMask pattern(s) using augmented wildcards.<br />:::&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Multiple patterns are delimited by a pipe (|). Only full path<br />:::&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; matches count.<br />:::<br />:::&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; /P:&nbsp; matches the root path specified by option /P<br />:::&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; **&nbsp; &nbsp;matches any 0 or more characters<br />:::&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; *&nbsp; &nbsp; matches any 0 or more characters except \<br />:::&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ?&nbsp; &nbsp; matches any 0 or 1 character except . or \<br />:::<br />:::&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;This option is only useful if the /S option is used.<br />:::<br />:::&nbsp; &nbsp; &nbsp; /PX PathExclusion<br />:::<br />:::&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Exclude files or folders whose parent folder path matches any<br />:::&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; of the PathExclusion pattern(s) using augmented wildcards.<br />:::&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Multiple patterns are delimited by a pipe (|). Only full path<br />:::&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; matches count.<br />:::<br />:::&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; /P:&nbsp; matches the root path specified by option /P<br />:::&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; **&nbsp; &nbsp;matches any 0 or more characters<br />:::&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; *&nbsp; &nbsp; matches any 0 or more characters except \<br />:::&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ?&nbsp; &nbsp; matches any 0 or 1 character except . or \<br />:::<br />:::&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;This option is only useful if the /S option is used.<br />:::<br />:::&nbsp; &nbsp; &nbsp; /RFM RegexFileOrFoldereMask<br />:::<br />:::&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Only rename files or folders that match the regular expression,<br />:::&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ignoring case. Partial name matches count.<br />:::<br />:::&nbsp; &nbsp; &nbsp; /RFX RegexFileOrFolderExclusion<br />:::<br />:::&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Exclude files or folders that match the regular Expression,<br />:::&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ignoring case. Partial name matches count.<br />:::<br />:::&nbsp; &nbsp; &nbsp; /RPM RegexPathMask<br />:::<br />:::&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Only rename files or folders whose parent folder path matches the<br />:::&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; RegexPathMask regular expression, ignoring case. Partial path<br />:::&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; matches count. This option is really only useful if the /S<br />:::&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; option is used.<br />:::<br />:::&nbsp; &nbsp; &nbsp; /RPX RegexPathExclusion<br />:::<br />:::&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Exclude files or folders whose parent folder path matches the<br />:::&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; RegexPathExclusion regular expression, ignoring case. Partial<br />:::&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; path matches count. This option is really only useful if the<br />:::&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; /S option is used.<br />:::<br />:::&nbsp; &nbsp; &nbsp; /Q&nbsp; - Do not list the renamed files/folders (Quiet mode).<br />:::<br />:::&nbsp; &nbsp; &nbsp; /S&nbsp; - Recurse Subdirectories.<br />:::<br />:::&nbsp; &nbsp; &nbsp; /T&nbsp; - List the rename operations that would be attempted,<br />:::&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; but do not rename anything. (Test mode)<br />:::<br />:::&nbsp; &nbsp; &nbsp; /U&nbsp; - Convert names to Upper case. Entire names can be converted to<br />:::&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; upper case without any other changes by using empty strings (&quot;&quot;)<br />:::&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; for both Search and Replace.<br />:::<br />:::&nbsp; Help is available by supplying a single argument beginning with /?:<br />:::<br />:::&nbsp; &nbsp; &nbsp; /?&nbsp; &nbsp; &nbsp; &nbsp; - Writes this help documentation to stdout.<br />:::<br />:::&nbsp; &nbsp; &nbsp; /?REGEX&nbsp; &nbsp;- Opens up Microsoft's JScript regular expression<br />:::&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; documentation within your browser.<br />:::<br />:::&nbsp; &nbsp; &nbsp; /?REPLACE - Opens up Microsoft's JScript REPLACE documentation<br />:::&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; within your browser.<br />:::<br />:::&nbsp; &nbsp; &nbsp; /?VERSION - Writes the JREN version number to stdout.<br />:::<br />:::&nbsp; &nbsp; &nbsp; /?TS()&nbsp; &nbsp; - Writes documentation for the ts() function to stdout.<br />:::<br />:::&nbsp; JREN.BAT was written by Dave Benham, and originally posted at<br />:::&nbsp; http://www.dostips.com/forum/viewtopic.php?f=3&amp;t=6081<br />:::<br />:: =============== ts() documentation ===============<br />::+<br />::+ts( &#91; { &#91;option:value &#91;,option:value&#93;...&#93; } &#93; )<br />::+&nbsp; <br />::+&nbsp; A JScript function that can performs date and time computations and return<br />::+&nbsp; a formatted time string.<br />::+&nbsp; <br />::+&nbsp; The option object argument within curly braces is optional - if no argument<br />::+&nbsp; is given, then it returns the current timestamp using compressed ISO 8601<br />::+&nbsp; format with milliseconds and local time zone - YYYYMMDDThhmmss.fff+zzzz<br />::+&nbsp; <br />::+&nbsp; &nbsp; Examples:<br />::+&nbsp; &nbsp; &nbsp; ts()&nbsp; - Current date/time:&nbsp; YYYYMMDDThhmmss.fff+zzzz<br />::+&nbsp; &nbsp; &nbsp; ts({dt:'created',fmt:'{iso-dt}'})&nbsp; - The file create date:&nbsp; YYYY-MM-DD<br />::+&nbsp; &nbsp; &nbsp; ts({od:-1,fmt:'{YYYY}_{MM}_{DD}'}) - Yesterday's date:&nbsp; YYYY_MM_DD<br />::+&nbsp; <br />::+&nbsp; Option names are case sensitive. There are 5 types of options:<br />::+&nbsp; &nbsp; 1) Specify the base date&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; - dt:<br />::+&nbsp; &nbsp; 2) Specify date/time offsets&nbsp; &nbsp; &nbsp; - oy: om: od: oh: on: os: of:<br />::+&nbsp; &nbsp; 3) Specify the output time zone&nbsp; &nbsp;- tz:<br />::+&nbsp; &nbsp; 4) Specify the output format&nbsp; &nbsp; &nbsp; - fmt:<br />::+&nbsp; &nbsp; 5) Configure the day-of-week and&nbsp; - wkd: weekday: mth: month:<br />::+&nbsp; &nbsp; &nbsp; &nbsp;month names for non-English<br />::+&nbsp; &nbsp; &nbsp; &nbsp;users<br />::+<br />::+&nbsp; Specify the base date and time<br />::+<br />::+&nbsp; &nbsp; dt:&nbsp; Value specifies the base date and time. Many formats supported:<br />::+<br />::+&nbsp; &nbsp; &nbsp; Current local date/time<br />::+&nbsp; &nbsp; &nbsp; &nbsp; - do not specify a dt: value<br />::+&nbsp; &nbsp; &nbsp; &nbsp; - undefined value<br />::+&nbsp; &nbsp; &nbsp; &nbsp; - empty string ''<br />::+<br />::+&nbsp; &nbsp; &nbsp; &nbsp; Examples:<br />::+&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; dt:''<br />::+&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; dt:undefined<br />::+<br />::+&nbsp; &nbsp; &nbsp; Milliseconds since 1970-01-01 00:00:00 UTC<br />::+&nbsp; &nbsp; &nbsp; &nbsp; - NumericExpression (math OK)<br />::+&nbsp; &nbsp; &nbsp; &nbsp; - NumericString (no math)<br />::+<br />::+&nbsp; &nbsp; &nbsp; &nbsp; Examples:<br />::+&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; dt: 1391230800000&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; = January 1, 19970 00:00:00 UTC<br />::+&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; dt: 1391230000000+800000&nbsp; &nbsp;= January 1, 19970 00:00:00 UTC<br />::+&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; dt:'1391230800000'&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= January 1, 19970 00:00:00 UTC<br />::+&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; dt:'1391230000000+800000'&nbsp; = error<br />::+<br />::+&nbsp; &nbsp; &nbsp; String timestamp representation<br />::+&nbsp; &nbsp; &nbsp; &nbsp; - Any string accepted by the JScript Date.Parse() method.<br />::+&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; See http://msdn.microsoft.com/en-us/library/k4w173wk(v=vs.84).aspx<br />::+<br />::+&nbsp; &nbsp; &nbsp; &nbsp; Examples: All of the following represent Midnight on January 4, 2013<br />::+&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; assuming local time zone is U.S Eastern Standard Time (EST)<br />::+<br />::+&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; dt:'1-4-2013'&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Defaults to local time zone<br />::+&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; dt:'January 4, 2013 EST'&nbsp; &nbsp; &nbsp; &nbsp;Explicit Eastern Std Time (US)<br />::+&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; dt:'2013/1/4 -05'&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Explicit Eastern Std Time (US)<br />::+&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; dt:'Jan 3 2013 23: CST'&nbsp; &nbsp; &nbsp; &nbsp; Central Standard Time (US)<br />::+&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; dt:'2013 3 Jan 9:00 pm -0800'&nbsp; Pacific Standard Time (US)<br />::+&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; dt:'01/04/2013 05:00:00 UTC'&nbsp; &nbsp;Universal Coordinated Time<br />::+&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; dt:'1/4/2013 05:30 +0530'&nbsp; &nbsp; &nbsp; India Standard Time<br />::+<br />::+&nbsp; &nbsp; &nbsp; File timestamps to millisecond accuracy using WMI. Very slow, but<br />::+&nbsp; &nbsp; &nbsp; locale agnostic. WMI call may not work on some older machines.<br />::+&nbsp; &nbsp; &nbsp; &nbsp; - 'created'&nbsp; &nbsp;= Creation date/time of the file<br />::+&nbsp; &nbsp; &nbsp; &nbsp; - 'modified'&nbsp; = Last Modified date/time of the file<br />::+&nbsp; &nbsp; &nbsp; &nbsp; - 'accessed'&nbsp; = Last Accessed date/time of the file<br />::+<br />::+&nbsp; &nbsp; &nbsp; &nbsp; Example:<br />::+&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; dt:'created'&nbsp; = creation date/time of the file to be renamed<br />::+<br />::+&nbsp; &nbsp; &nbsp; File timestamps to second accuracy using FileSystemObject. Very fast,<br />::+&nbsp; &nbsp; &nbsp; but locale dependent. May not parse properly for some countries.<br />::+&nbsp; &nbsp; &nbsp; &nbsp; - 'fsoCreated'&nbsp; = Creation date/time of the file<br />::+&nbsp; &nbsp; &nbsp; &nbsp; - 'fsoModified' = Last Modified date/time of the file<br />::+&nbsp; &nbsp; &nbsp; &nbsp; - 'fsoAccessed' = Last Accessed date/time of the file<br />::+<br />::+&nbsp; &nbsp; &nbsp; Array with 2 to 7 numeric expressions (local time only)<br />::+&nbsp; &nbsp; &nbsp; &nbsp; - &#91;year,months,days,hours,minutes,seconds,milliseconds&#93;<br />::+&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; year and months are required, the rest are optional<br />::+&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Missing values are assumed to be 0<br />::+&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Missing values are not allowed between specified values<br />::+&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; month 0 = January<br />::+&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; day 1 = First day of month, day 0 = Last day of prior month<br />::+<br />::+&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Examples:<br />::+&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; dt:&#91;2014,3,1,17,30,22,457&#93;&nbsp; = April 1, 2014, 17:30:22.457<br />::+&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; dt:&#91;2014,0,1&#93;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= January 1, 2014, 00:00:00<br />::+&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; dt:&#91;2014,0&#93;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= December 31, 2013, 00:00:00<br />::+&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; dt:&#91;2014,,10&#93;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= error<br />::+<br />::+&nbsp; Date/Time offsets and time zone options all use the same syntax.<br />::+&nbsp; The value represents a numeric offset for the specified time unit.<br />::+&nbsp; It may be expressed as a numeric expression (math allowed), or<br />::+&nbsp; a numeric string (no math allowed). Both positive and negative<br />::+&nbsp; values may be used.<br />::+<br />::+&nbsp; &nbsp; oy:&nbsp; Year offset<br />::+&nbsp; &nbsp; om:&nbsp; Months offset<br />::+&nbsp; &nbsp; od:&nbsp; Days offset<br />::+&nbsp; &nbsp; oh:&nbsp; Hours offset<br />::+&nbsp; &nbsp; on:&nbsp; Minutes offset<br />::+&nbsp; &nbsp; os:&nbsp; Seconds offset<br />::+&nbsp; &nbsp; of:&nbsp; Milliseconds (Fractional seconds) offset<br />::+<br />::+&nbsp; &nbsp; tz:&nbsp; Time zone used for output = minutes offset from UTC<br />::+<br />::+&nbsp; The fmt: option is a string that specifies the format of the output.<br />::+&nbsp; Strings within curly braces are replaced by dynamic components that are<br />::+&nbsp; derived from the computed time stamp. Strings within braces that do not<br />::+&nbsp; match a fmt: component are left as is. Strings not in braces are left<br />::+&nbsp; as is. The format component names are not case senstive.<br />::+<br />::+&nbsp; For example, a U.S. date would be represented as fmt:'{yyyy}/{mm}/{dd}'<br />::+<br />::+&nbsp; The default format is '{ISOTS}', which yields YYYYMMDDThhmmss.fff+hhmm<br />::+<br />::+&nbsp; &nbsp; {YYYY}&nbsp; 4 digit year, zero padded<br />::+<br />::+&nbsp; &nbsp; {YY}&nbsp; &nbsp; 2 digit year, zero padded<br />::+<br />::+&nbsp; &nbsp; {Y}&nbsp; &nbsp; &nbsp;year without zero padding<br />::+<br />::+&nbsp; &nbsp; {MONTH} month name<br />::+<br />::+&nbsp; &nbsp; {MTH}&nbsp; &nbsp;month abbreviation<br />::+<br />::+&nbsp; &nbsp; {MM}&nbsp; &nbsp; 2 digit month, zero padded<br />::+<br />::+&nbsp; &nbsp; {M}&nbsp; &nbsp; &nbsp;month without zero padding<br />::+<br />::+&nbsp; &nbsp; {WEEKDAY} day of week name<br />::+<br />::+&nbsp; &nbsp; {WKD}&nbsp; &nbsp;day of week abbreviation<br />::+<br />::+&nbsp; &nbsp; {W}&nbsp; &nbsp; &nbsp;day of week number, 0=Sunday<br />::+<br />::+&nbsp; &nbsp; {DD}&nbsp; &nbsp; 2 digit day, zero padded<br />::+<br />::+&nbsp; &nbsp; {D}&nbsp; &nbsp; &nbsp;day without zero padding<br />::+<br />::+&nbsp; &nbsp; {HH}&nbsp; &nbsp; 2 digit hours, 24 hour format, zero padded<br />::+<br />::+&nbsp; &nbsp; {H}&nbsp; &nbsp; &nbsp;hours, 24 hour format without zero padding<br />::+<br />::+&nbsp; &nbsp; {HH12}&nbsp; 2 digit hours, 12 hour format, zero padded<br />::+<br />::+&nbsp; &nbsp; {H12}&nbsp; &nbsp;hours, 12 hour format without zero padding<br />::+<br />::+&nbsp; &nbsp; {NN}&nbsp; &nbsp; 2 digit minutes, zero padded<br />::+<br />::+&nbsp; &nbsp; {N}&nbsp; &nbsp; &nbsp;minutes without padding<br />::+<br />::+&nbsp; &nbsp; {SS}&nbsp; &nbsp; 2 digit seconds, zero padded<br />::+<br />::+&nbsp; &nbsp; {S}&nbsp; &nbsp; &nbsp;seconds without padding<br />::+<br />::+&nbsp; &nbsp; {FFF}&nbsp; &nbsp;3 digit milliseconds, zero padded<br />::+<br />::+&nbsp; &nbsp; {F}&nbsp; &nbsp; &nbsp;milliseconds without padding<br />::+<br />::+&nbsp; &nbsp; {AM}&nbsp; &nbsp; AM or PM in upper case<br />::+<br />::+&nbsp; &nbsp; {PM}&nbsp; &nbsp; am or pm in lower case<br />::+<br />::+&nbsp; &nbsp; {ZZZZ}&nbsp; timezone expressed as minutes offset from UTC,<br />::+&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; zero padded to 3 digits with sign<br />::+<br />::+&nbsp; &nbsp; {Z}&nbsp; &nbsp; &nbsp;timzone minutes offset from UTC without padding<br />::+<br />::+&nbsp; &nbsp; {ZS}&nbsp; &nbsp; timezone sign<br />::+<br />::+&nbsp; &nbsp; {ZH}&nbsp; &nbsp; timezone hours hours offset from UTC, (no sign),<br />::+&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; padded to 2 digits<br />::+<br />::+&nbsp; &nbsp; {ZM}&nbsp; &nbsp; timezone minutes offset from UTC (no sign),<br />::+&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; padded to 2 digits<br />::+<br />::+&nbsp; &nbsp; {ISOTS} YYYYMMDDThhmmss.fff+hhss<br />::+&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Compressed ISO 8601 date/time (timestamp) with milliseconds<br />::+&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; and time zone<br />::+<br />::+&nbsp; &nbsp; {ISODT} YYYYMMDD<br />::+&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Compressed ISO 8601 date format<br />::+<br />::+&nbsp; &nbsp; {ISOTM} hhmmss.fff<br />::+&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Compressed ISO 8601 time format with milliseconds<br />::+<br />::+&nbsp; &nbsp; {ISOTZ} +hhmm<br />::+&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Compressed ISO 8601 timezone format<br />::+<br />::+&nbsp; &nbsp; {ISO-TS} YYYY-MM-DDThh:mm:ss.fff+hh:ss<br />::+&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;ISO 8601 date/time (timestamp) with milliseconds and time zone<br />::+<br />::+&nbsp; &nbsp; {ISO-DT} YYYY-MM-DD<br />::+&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;ISO 8601 date format<br />::+<br />::+&nbsp; &nbsp; {ISO-TM} hh:mm:ss.fff<br />::+&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;ISO 8601 time format with milliseconds<br />::+<br />::+&nbsp; &nbsp; {ISO-TZ} +hh:mm<br />::+&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;ISO 8601 timezone<br />::+<br />::+&nbsp; &nbsp; {U}&nbsp; &nbsp; &nbsp;Unix Epoch time: same as {US}<br />::+&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Seconds since 1970-01-01 00:00:00 UTC.<br />::+&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Negative numbers represent dates prior to 1970-01-01.<br />::+&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; This value should not be used with the -TZ option<br />::+<br />::+&nbsp; &nbsp; {UMS}&nbsp; &nbsp;Milliseconds since 1970-01-01 00:00:00.000 UTC.<br />::+&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Negative numbers represent days prior to 1970-01-01.<br />::+&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; This value should not be used with the -TZ option<br />::+<br />::+&nbsp; &nbsp; {US}&nbsp; &nbsp; Seconds since 1970-01-01 00:00:00.000 UTC.<br />::+&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Negative numbers represent days prior to 1970-01-01.<br />::+&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; This value should not be used with the -TZ option<br />::+<br />::+&nbsp; &nbsp; {UM}&nbsp; &nbsp; Minutes since 1970-01-01 00:00:00.000 UTC.<br />::+&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Negative numbers represent days prior to 1970-01-01.<br />::+&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; This value should not be used with the -TZ option<br />::+<br />::+&nbsp; &nbsp; {UH}&nbsp; &nbsp; Hours since 1970-01-01 00:00:00.000 UTC.<br />::+&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Negative numbers represent days prior to 1970-01-01.<br />::+&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; This value should not be used with the -TZ option<br />::+<br />::+&nbsp; &nbsp; {UD}&nbsp; &nbsp; Days since 1970-01-01 00:00:00.000 UTC.<br />::+&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Negative numbers represent days prior to 1970-01-01.<br />::+&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; This value should not be used with the -TZ option<br />::+<br />::+&nbsp; &nbsp; {USD}&nbsp; &nbsp;Decimal seconds since 1970-01-01 00:00:00.000 UTC.<br />::+&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Negative numbers represent days prior to 1970-01-01.<br />::+&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; This value should not be used with the -TZ option<br />::+<br />::+&nbsp; &nbsp; {UMD}&nbsp; &nbsp;Decimal minutes since 1970-01-01 00:00:00.000 UTC.<br />::+&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Negative numbers represent days prior to 1970-01-01.<br />::+&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; This value should not be used with the -TZ option<br />::+<br />::+&nbsp; &nbsp; {UHD}&nbsp; &nbsp;Decimal hours since 1970-01-01 00:00:00.000 UTC.<br />::+&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Negative numbers represent days prior to 1970-01-01.<br />::+&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; This value should not be used with the -TZ option<br />::+<br />::+&nbsp; &nbsp; {UDD}&nbsp; &nbsp;Decimal days since 1970-01-01 00:00:00.000 UTC.<br />::+&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Negative numbers represent days prior to 1970-01-01.<br />::+&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; This value should not be used with the -TZ option<br />::+<br />::+&nbsp; &nbsp; {{}&nbsp; &nbsp; &nbsp;A { character<br />::+<br />::+&nbsp; The following options override the default English names for the months<br />::+&nbsp; and days of the week. The value for each option is a space delimited list<br />::+&nbsp; of names or abbreviations.<br />::+<br />::+&nbsp; &nbsp; wkd: Day of week abbreviations<br />::+&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;default = 'Sun Mon Tue Wed Thu Fri Sat'<br />::+<br />::+&nbsp; &nbsp; weekday: Day of week names<br />::+&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;default = 'Sunday Monday Tuesday Wednesday Thursday Friday'<br />::+<br />::+&nbsp; &nbsp; mth: Month abbreviations<br />::+&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;default = 'Jan Feb Mar Apr May Jun Jul Aug Sep Oct Nov Dec'<br />::+<br />::+&nbsp; &nbsp; month: Month names<br />::+&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;default = 'January February March April May Jun July August'<br />::+&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;+ ' September October November December'<br />::+<br />============= :Batch portion ============<br />@echo off<br />setlocal disableDelayedExpansion<br /><br />if .%2 equ . (<br />&nbsp; set &quot;test=%~1&quot;<br />&nbsp; setlocal enableDelayedExpansion<br />&nbsp; if &quot;!test:~0,1!&quot; equ &quot;-&quot; set &quot;test=/!test:~1!&quot;<br />&nbsp; if &quot;!test!&quot; equ &quot;/?&quot; (<br />&nbsp; &nbsp; for /f &quot;tokens=* delims=:&quot; %%A in ('findstr &quot;^:::&quot; &quot;%~f0&quot;') do @echo(%%A<br />&nbsp; &nbsp; exit /b 0<br />&nbsp; ) else if /i &quot;!test!&quot; equ &quot;/?ts()&quot; (<br />&nbsp; &nbsp; for /f &quot;tokens=* delims=:+&quot; %%A in ('findstr &quot;^::+&quot; &quot;%~f0&quot;') do @echo(%%A<br />&nbsp; &nbsp; exit /b 0<br />&nbsp; ) else if /i &quot;!test!&quot; equ &quot;/?regex&quot; (<br />&nbsp; &nbsp; explorer &quot;http://msdn.microsoft.com/en-us/library/ae5bf541(v=vs.80).aspx&quot;<br />&nbsp; &nbsp; exit /b 0<br />&nbsp; ) else if /i &quot;!test!&quot; equ &quot;/?replace&quot; (<br />&nbsp; &nbsp; explorer &quot;http://msdn.microsoft.com/en-US/library/efy6s3e6(v=vs.80).aspx&quot;<br />&nbsp; &nbsp; exit /b 0<br />&nbsp; ) else if /i &quot;!test!&quot; equ &quot;/?version&quot; (<br />&nbsp; &nbsp; for /f &quot;tokens=* delims=:&quot; %%A in ('findstr &quot;^::JREN\.BAT&quot; &quot;%~f0&quot;') do @echo(%%A<br />&nbsp; &nbsp; exit /b 0<br />&nbsp; ) else (<br />&nbsp; &nbsp; call :err &quot;Insufficient arguments&quot;<br />&nbsp; &nbsp; exit /b 2<br />&nbsp; )<br />)<br /><br />:: Define options<br />set &quot;options= /D: /FM:&quot;&quot; /FX:&quot;&quot; /I: /J: /L: /LIST: /NBEG:1 /NINC:1 /NPAD:3 /P:. /PM:&quot;&quot; /PX:&quot;&quot; /RFM:&quot;&quot; /RFX:&quot;&quot; /RPM:&quot;&quot; /RPX:&quot;&quot; /Q: /S: /T: /U: &quot;<br /><br />:: Set default option values<br />for %%O in (%options%) do for /f &quot;tokens=1,* delims=:&quot; %%A in (&quot;%%O&quot;) do set &quot;%%A=%%~B&quot;<br /><br />:: Get options<br />:loop<br />if not &quot;%~3&quot;==&quot;&quot; (<br />&nbsp; set &quot;test=%~3&quot;<br />&nbsp; setlocal enableDelayedExpansion<br />&nbsp; if &quot;!test:~0,1!&quot; equ &quot;-&quot; set &quot;test=/!test:~1!&quot;<br />&nbsp; if &quot;!test:~0,1!&quot; neq &quot;/&quot; (<br />&nbsp; &nbsp; call :err &quot;Too many arguments&quot;<br />&nbsp; &nbsp; exit /b 2<br />&nbsp; )<br />&nbsp; for /f &quot;delims=&quot; %%A in (&quot;!test!&quot;) do (<br />&nbsp; &nbsp; set &quot;test=!options:*%%A:=! &quot;<br />&nbsp; &nbsp; if &quot;!test!&quot;==&quot;!options! &quot; (<br />&nbsp; &nbsp; &nbsp; &nbsp; endlocal<br />&nbsp; &nbsp; &nbsp; &nbsp; call :err &quot;Invalid option %~3&quot;<br />&nbsp; &nbsp; &nbsp; &nbsp; exit /b 2<br />&nbsp; &nbsp; ) else if &quot;!test:~0,1!&quot;==&quot; &quot; (<br />&nbsp; &nbsp; &nbsp; &nbsp; endlocal<br />&nbsp; &nbsp; &nbsp; &nbsp; set &quot;%%A=1&quot;<br />&nbsp; &nbsp; &nbsp; &nbsp; if /i &quot;%%A&quot; equ &quot;/L&quot; set &quot;/U=&quot;<br />&nbsp; &nbsp; &nbsp; &nbsp; if /i &quot;%%A&quot; equ &quot;/U&quot; set &quot;/L=&quot;<br />&nbsp; &nbsp; ) else (<br />&nbsp; &nbsp; &nbsp; &nbsp; endlocal<br />&nbsp; &nbsp; &nbsp; &nbsp; if %4. equ . (<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; call :err &quot;Missing %~3 value&quot;<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; exit /b 2<br />&nbsp; &nbsp; &nbsp; &nbsp; )<br />&nbsp; &nbsp; &nbsp; &nbsp; set &quot;%%A=%~4&quot;<br />&nbsp; &nbsp; &nbsp; &nbsp; shift /3<br />&nbsp; &nbsp; )<br />&nbsp; )<br />&nbsp; shift /3<br />&nbsp; goto :loop<br />)<br /><br />:: Execute<br />cscript //E:JScript //nologo &quot;%~f0&quot; %1 %2<br />exit /b %errorlevel%<br /><br />:err<br />&gt;&amp;2 (<br />&nbsp; echo ERROR: %~1<br />)<br />exit /b<br /><br />************* JScript portion **********/<br />var $n<br />var _g=new Object();<br />try {<br /><br />&nbsp; _g.defineReplFunc=function() {<br />&nbsp; &nbsp; eval(_g.replFunc);<br />&nbsp; }<br /><br />&nbsp; _g.main=function() {<br /><br />&nbsp; &nbsp; function err( msg, rtn ) {<br />&nbsp; &nbsp; &nbsp; WScript.StdErr.WriteLine(msg);<br />&nbsp; &nbsp; &nbsp; if (rtn) WScript.Quit(rtn);<br />&nbsp; &nbsp; }<br /><br />&nbsp; &nbsp; function BuildRegex( loc, regex, options ) {<br />&nbsp; &nbsp; &nbsp; try {<br />&nbsp; &nbsp; &nbsp; &nbsp; return regex ? new RegExp( regex, options ) : false;<br />&nbsp; &nbsp; &nbsp; } catch(e) {<br />&nbsp; &nbsp; &nbsp; &nbsp; err( 'Invalid '+loc+' regular expression: '+e.message, 1);<br />&nbsp; &nbsp; &nbsp; }<br />&nbsp; &nbsp; }<br /><br />&nbsp; &nbsp; function GetInt( loc, numStr, minVal ) {<br />&nbsp; &nbsp; &nbsp; var n = parseInt( numStr );<br />&nbsp; &nbsp; &nbsp; if (isNaN(n) || n&lt;minVal) {<br />&nbsp; &nbsp; &nbsp; &nbsp; err( 'Error: Invalid '+loc+' value', 1 );<br />&nbsp; &nbsp; &nbsp; }<br />&nbsp; &nbsp; &nbsp; return n;<br />&nbsp; &nbsp; }<br /><br />&nbsp; &nbsp; var env = WScript.CreateObject(&quot;WScript.Shell&quot;).Environment(&quot;Process&quot;),<br />&nbsp; &nbsp; &nbsp; &nbsp; fso = new ActiveXObject(&quot;Scripting.FileSystemObject&quot;);<br /><br />&nbsp; &nbsp; try {<br />&nbsp; &nbsp; &nbsp; var root = fso.GetFolder( env('/P') );<br />&nbsp; &nbsp; } catch(e) {<br />&nbsp; &nbsp; &nbsp; err( 'Invalid /P path: '+e.message, 1 );<br />&nbsp; &nbsp; }<br /><br />&nbsp; &nbsp; function MaskRepl($0) {<br />&nbsp; &nbsp; &nbsp; switch ($0) {<br />&nbsp; &nbsp; &nbsp; &nbsp; case '/P:':<br />&nbsp; &nbsp; &nbsp; &nbsp; case '/p:': return root.Path.replace(/&#91;.^$*+?()&#91;{\\|&#93;/g,&quot;\\$&amp;&quot;);<br />&nbsp; &nbsp; &nbsp; &nbsp; case '**':&nbsp; return '.*';<br />&nbsp; &nbsp; &nbsp; &nbsp; case '*':&nbsp; &nbsp;return '&#91;^\\\\&#93;*';<br />&nbsp; &nbsp; &nbsp; &nbsp; case '?':&nbsp; &nbsp;return '&#91;^\\\\.&#93;?';<br />&nbsp; &nbsp; &nbsp; &nbsp; default:&nbsp; &nbsp; return '\\'+$0;<br />&nbsp; &nbsp; &nbsp; }<br />&nbsp; &nbsp; }<br /><br />&nbsp; &nbsp; var args=WScript.Arguments,<br />&nbsp; &nbsp; &nbsp; &nbsp; search = BuildRegex( 'Search', args.Item(0), env('/I')?'gi':'g' ),<br />&nbsp; &nbsp; &nbsp; &nbsp; replace=args.Item(1),<br />&nbsp; &nbsp; &nbsp; &nbsp; rMask = BuildRegex( '/RFM', env('/RFM'), 'i' ),<br />&nbsp; &nbsp; &nbsp; &nbsp; rExclude = BuildRegex( '/RFX', env('/RFX'), 'i' ),<br />&nbsp; &nbsp; &nbsp; &nbsp; rPathMask = BuildRegex( '/RPM', env('/RPM'), 'i' ),<br />&nbsp; &nbsp; &nbsp; &nbsp; rPathExclude = BuildRegex( '/RPX', env('/RPX'), 'i' ),<br />&nbsp; &nbsp; &nbsp; &nbsp; regex = new RegExp(&quot;/P:|&#91;*&#93;&#91;*&#93;|&#91;*&#93;|&#91;?&#93;|&#91;.^$+()&#91;{\\\\&#93;&quot;,&quot;ig&quot;);<br />&nbsp; &nbsp; &nbsp; &nbsp; mask = env('/FM') ? new RegExp( '^(?:' + env('/FM').replace(regex,MaskRepl) + ')$', 'i' ) : false;<br />&nbsp; &nbsp; &nbsp; &nbsp; exclude = env('/FX') ? new RegExp( '^(?:' + env('/FX').replace(regex,MaskRepl) + ')$', 'i' ) : false;<br />&nbsp; &nbsp; &nbsp; &nbsp; pathMask = env('/PM') ? new RegExp( '^(?:' + env('/PM').replace(regex,MaskRepl) + ')$', 'i' ) : false;<br />&nbsp; &nbsp; &nbsp; &nbsp; pathExclude = env('/PX') ? new RegExp( '^(?:' + env('/PX').replace(regex,MaskRepl) + ')$', 'i' ) : false;<br />&nbsp; &nbsp; &nbsp; &nbsp; upper = env('/U'),<br />&nbsp; &nbsp; &nbsp; &nbsp; lower = env('/L'),<br />&nbsp; &nbsp; &nbsp; &nbsp; recurse = env('/S'),<br />&nbsp; &nbsp; &nbsp; &nbsp; jscript = env('/J'),<br />&nbsp; &nbsp; &nbsp; &nbsp; list = env('/LIST'),<br />&nbsp; &nbsp; &nbsp; &nbsp; beg = GetInt( '/NBEG', env('/NBEG'), 0 ),<br />&nbsp; &nbsp; &nbsp; &nbsp; inc = GetInt( '/NINC', env('/NINC'), 1 ),<br />&nbsp; &nbsp; &nbsp; &nbsp; pad = GetInt( '/NPAD', env('/NPAD'), 1 ),<br />&nbsp; &nbsp; &nbsp; &nbsp; padStr = Array( pad+1 ).join('0'),<br />&nbsp; &nbsp; &nbsp; &nbsp; test = env('/T'),<br />&nbsp; &nbsp; &nbsp; &nbsp; quiet = env('/Q');<br /><br />&nbsp; &nbsp; _g.dirs = env('/D');<br /><br />&nbsp; &nbsp; function ProcessFolder( folder ) {<br />&nbsp; &nbsp; &nbsp; var i, a=&#91;&#93;;<br />&nbsp; &nbsp; &nbsp; var num = beg;<br />&nbsp; &nbsp; &nbsp; if (recurse || _g.dirs) {<br />&nbsp; &nbsp; &nbsp; &nbsp; var folders = new Enumerator(folder.SubFolders);<br />&nbsp; &nbsp; &nbsp; &nbsp; for( i=0 ; !folders.atEnd(); folders.moveNext()) {<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; a&#91;i++&#93;=folders.item()<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; if (recurse) ProcessFolder(folders.item());<br />&nbsp; &nbsp; &nbsp; &nbsp; }<br />&nbsp; &nbsp; &nbsp; }<br />&nbsp; &nbsp; &nbsp; if ( (!pathMask || pathMask.test(folder.Path)) &amp;&amp;<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;(!rPathMask || rPathMask.test(folder.Path)) &amp;&amp;<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;(!pathExclude || !pathExclude.test(folder.Path)) &amp;&amp;<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;(!rPathExclude || !rPathExclude.test(folder.Path)) ) {<br />&nbsp; &nbsp; &nbsp; &nbsp; if (!_g.dirs) {<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; a=&#91;&#93;;<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; var files = new Enumerator(folder.Files);<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; for (i=0; !files.atEnd(); files.moveNext()) a&#91;i++&#93;=files.item();<br />&nbsp; &nbsp; &nbsp; &nbsp; }<br />&nbsp; &nbsp; &nbsp; &nbsp; for (i=0; i&lt;a.length; i++) {<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; _g.file = a&#91;i&#93;;<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; _g.wmiFile = undefined;<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; var oldName = a&#91;i&#93;.Name;<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; if ( (!mask || mask.test(oldName)) &amp;&amp;<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;(!rMask || rMask.test(oldName)) &amp;&amp;<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;(!exclude || !exclude.test(oldName)) &amp;&amp;<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;(!rExclude || !rExclude.test(oldName)) ) {<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; if (jscript) {<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; $n = num.toString();<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; if ($n.length&lt;pad) $n = (padStr+$n).slice(-pad);<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; try {<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; var newName = oldName.replace( search, replace );<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; } catch(e) {<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; err( 'Replace error: '+e.message, 1 );<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; if (!list) newName=newName.replace( /&#91; .&#93;+$/, &quot;&quot; );<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; if (jscript &amp;&amp; !test &amp;&amp; !list &amp;&amp; newName.search(/&#91;&lt;&gt;|:/\\*?&quot;\x00-\x1F&#93;/)&gt;=0) err('Error: Invalid file name character in Replace',1);<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; if (upper) newName = uc(newName);<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; if (lower) newName = lc(newName);<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; if (newName != oldName || list) {<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; try {<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; var oldPath=a&#91;i&#93;.Path;<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; if (!test &amp;&amp; !list) {<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; if (a&#91;i&#93;.Name.toUpperCase() == newName.toUpperCase()) a&#91;i&#93;.Name = '_{JREN_tempName}_';<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; a&#91;i&#93;.Name = newName;<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; if (list) WScript.echo(newName);<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; else if (!quiet) WScript.echo( '&quot;'+oldPath+'&quot;&nbsp; --&gt;&nbsp; &quot;'+newName+'&quot;' );<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; } catch(e) {<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; if (a&#91;i&#93;.Name != oldName) a&#91;i&#93;.Name = oldName;<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; err( 'Unable to rename &quot;'+a&#91;i&#93;.Path+'&quot;&nbsp; --&gt;&nbsp; &quot;'+newName+'&quot; : &quot;'+e.message, 0 );<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; num+=inc;<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br />&nbsp; &nbsp; &nbsp; &nbsp; }<br />&nbsp; &nbsp; &nbsp; }<br />&nbsp; &nbsp; }<br /><br />&nbsp; &nbsp; if (jscript) {<br />&nbsp; &nbsp; &nbsp; var regex=new RegExp('.|'+search,''),<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; cnt;<br />&nbsp; &nbsp; &nbsp; 'x'.replace( regex, function(){cnt=arguments.length-2; return '';} );<br />&nbsp; &nbsp; &nbsp; _g.replFunc='_g.replFunc=function($0';<br />&nbsp; &nbsp; &nbsp; for (var i=1; i&lt;cnt; i++) _g.replFunc+=',$'+i;<br />&nbsp; &nbsp; &nbsp; _g.replFunc+=',$off,$src){return eval(_g.replace);}';<br />&nbsp; &nbsp; &nbsp; _g.defineReplFunc();<br />&nbsp; &nbsp; &nbsp; _g.replace = replace;<br />&nbsp; &nbsp; &nbsp; replace = _g.replFunc;<br />&nbsp; &nbsp; } else if (replace.search(/&#91;&lt;&gt;|:/\\*?&quot;\x00-\x1F&#93;/)&gt;=0) err('Error: Invalid file name character in Replace',1);<br /><br />&nbsp; &nbsp; ProcessFolder( root );<br />&nbsp; &nbsp; WScript.Quit(0);<br />&nbsp; }<br /><br />&nbsp; _g.main();<br /><br />} catch(e) {<br />&nbsp; WScript.StdErr.WriteLine(&quot;JScript runtime error: &quot;+e.message);<br />&nbsp; WScript.Quit(1);<br />}<br /><br />function lc(str) { return str.toLowerCase(); }<br /><br />function uc(str) { return str.toUpperCase(); }<br /><br />function lpad( val, pad ) {<br />&nbsp; if (!pad) pad='';<br />&nbsp; var rtn=val.toString();<br />&nbsp; return (rtn.length&lt;pad.length) ? (pad+rtn).slice(-pad.length) : val;<br />}<br /><br />function rpad( val, pad ) {<br />&nbsp; if (!pad) pad='';<br />&nbsp; var rtn=val.toString();<br />&nbsp; return (rtn.length&lt;pad.length) ? (rtn+pad).slice(0,pad.length) : val;<br />}<br /><br />function ts(opt) {<br />&nbsp; if (opt===undefined) opt={};<br />&nbsp; if (opt.constructor !== Object) badOp('ts()');<br />&nbsp; if (!opt.wkd)&nbsp; &nbsp; &nbsp;opt.wkd='Sun Mon Tue Wed Thu Fri Sat';<br />&nbsp; if (!opt.weekday) opt.weekday='Sunday Monday Tuesday Wednesday Thursday Friday Saturday';<br />&nbsp; if (!opt.mth)&nbsp; &nbsp; &nbsp;opt.mth='Jan Feb Mar Apr May Jun Jul Aug Sep Oct Nov Dec';<br />&nbsp; if (!opt.month)&nbsp; &nbsp;opt.month='January February March April May June July August September October November December';<br />&nbsp; if (!opt.fmt)&nbsp; &nbsp; &nbsp;opt.fmt='{isots}';<br /><br />&nbsp; var wkd&nbsp; &nbsp; &nbsp;= opt.wkd.split(' '),<br />&nbsp; &nbsp; &nbsp; weekday = opt.weekday.split(' '),<br />&nbsp; &nbsp; &nbsp; mth&nbsp; &nbsp; &nbsp;= opt.mth.split(' '),<br />&nbsp; &nbsp; &nbsp; month&nbsp; &nbsp;= opt.month.split(' '),<br />&nbsp; &nbsp; &nbsp; y,m,d,w,h,h12,n,s,f,u,z,zs,za, dt,<br />&nbsp; &nbsp; &nbsp; sp=' ', ps='/', pc=':', pd='-', pp='.', p2='00', p3='000', p4='0000';<br />&nbsp; if (wkd.length!=7)&nbsp; &nbsp; &nbsp;badOp('wkd');<br />&nbsp; if (weekday.length!=7) badOp('weekday');<br />&nbsp; if (mth.length!=12)&nbsp; &nbsp; badOp('mth');<br />&nbsp; if (month.length!=12)&nbsp; badOp('month');<br /><br />&nbsp; dt = getDt(opt.dt);<br />&nbsp; if (opt.oy) dt.setFullYear(&nbsp; &nbsp; &nbsp;dt.getFullYear()&nbsp; &nbsp; +getNum('oy'));<br />&nbsp; if (opt.om) dt.setMonth(&nbsp; &nbsp; &nbsp; &nbsp; dt.getMonth()&nbsp; &nbsp; &nbsp; &nbsp;+getNum('om'));<br />&nbsp; if (opt.od) dt.setDate(&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;dt.getDate()&nbsp; &nbsp; &nbsp; &nbsp; +getNum('od'));<br />&nbsp; if (opt.oh) dt.setHours(&nbsp; &nbsp; &nbsp; &nbsp; dt.getHours()&nbsp; &nbsp; &nbsp; &nbsp;+getNum('oh'));<br />&nbsp; if (opt.on) dt.setMinutes(&nbsp; &nbsp; &nbsp; dt.getMinutes()&nbsp; &nbsp; &nbsp;+getNum('on'));<br />&nbsp; if (opt.os) dt.setSeconds(&nbsp; &nbsp; &nbsp; dt.getSeconds()&nbsp; &nbsp; &nbsp;+getNum('os'));<br />&nbsp; if (opt.of) dt.setMilliseconds( dt.getMilliseconds()+getNum('of'));<br />&nbsp; if (opt.tz) dt.setMinutes(&nbsp; &nbsp; &nbsp; dt.getMinutes()&nbsp; +(z=getNum('tz')));<br /><br />&nbsp; y = opt.tz!==undefined ? dt.getUTCFullYear(): dt.getFullYear();<br />&nbsp; m = opt.tz!==undefined ? dt.getUTCMonth()&nbsp; &nbsp;: dt.getMonth();<br />&nbsp; d = opt.tz!==undefined ? dt.getUTCDate()&nbsp; &nbsp; : dt.getDate();<br />&nbsp; w = opt.tz!==undefined ? dt.getUTCDay()&nbsp; &nbsp; &nbsp;: dt.getDay();<br />&nbsp; h = opt.tz!==undefined ? dt.getUTCHours()&nbsp; &nbsp;: dt.getHours();<br />&nbsp; n = opt.tz!==undefined ? dt.getUTCMinutes() : dt.getMinutes();<br />&nbsp; s = opt.tz!==undefined ? dt.getUTCSeconds() : dt.getSeconds();<br />&nbsp; f = opt.tz!==undefined ? dt.getUTCMilliseconds() : dt.getMilliseconds();<br />&nbsp; u = dt.getTime();<br /><br />&nbsp; h12 = h%12;<br />&nbsp; if (!h12) h12=12;<br /><br />&nbsp; if (!opt.tz) z=-dt.getTimezoneOffset();<br />&nbsp; zs = z&lt;0 ? '-' : '+';<br />&nbsp; za = Math.abs(z);<br /><br />&nbsp; return opt.fmt.replace( /\{(.*?)\}/gi, repl );<br /><br />&nbsp; function getNum( v ) {<br />&nbsp; &nbsp; var rtn = Number(opt&#91;v&#93;);<br />&nbsp; &nbsp; if (isNaN(rtn-rtn)) badOp(v);<br />&nbsp; &nbsp; return rtn;<br />&nbsp; }<br /><br />&nbsp; function getDt( v ) {<br />&nbsp; &nbsp; var dt, n;<br />&nbsp; &nbsp; if (v===undefined) {<br />&nbsp; &nbsp; &nbsp; dt = new Date();<br />&nbsp; &nbsp; } else switch (v.constructor) {<br />&nbsp; &nbsp; &nbsp; case Date:<br />&nbsp; &nbsp; &nbsp; case Number:<br />&nbsp; &nbsp; &nbsp; &nbsp; dt = new Date(v);<br />&nbsp; &nbsp; &nbsp; &nbsp; break;<br />&nbsp; &nbsp; &nbsp; case Array:<br />&nbsp; &nbsp; &nbsp; &nbsp; try {dt=eval( 'new Date('+v.join(',')+')' )} catch(e){}<br />&nbsp; &nbsp; &nbsp; &nbsp; break;<br />&nbsp; &nbsp; &nbsp; case String:<br />&nbsp; &nbsp; &nbsp; &nbsp; switch (v.toLowerCase()) {<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; case '':&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;dt = new Date(); break;<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; case 'created':&nbsp; dt = getWmiDt('c'); break;<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; case 'modified': dt = getWmiDt('m'); break;<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; case 'accessed': dt = getWmiDt('a'); break;<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; case 'fsocreated':&nbsp; dt = new Date(_g.file.DateCreated); break;<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; case 'fsomodified': dt = new Date(_g.file.DateLastModified); break;<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; case 'fsoaccessed': dt = new Date(_g.file.DateLastAccessed); break;<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; default:<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; n=Number(v);<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; if (isNaN(n-n)) dt = new Date(v);<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; else&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; dt = new Date(n);<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; break;<br />&nbsp; &nbsp; &nbsp; &nbsp; }<br />&nbsp; &nbsp; &nbsp; &nbsp; break;<br />&nbsp; &nbsp; }<br />&nbsp; &nbsp; if (isNaN(dt)) badOp('dt');<br />&nbsp; &nbsp; return dt;<br />&nbsp; }<br />&nbsp;<br />&nbsp; function badOp(option) {<br />&nbsp; &nbsp; throw new Error('Invalid '+option+' value');<br />&nbsp; }<br /><br />&nbsp; function trunc( n ) { return Math&#91;n&gt;0?&quot;floor&quot;:&quot;ceil&quot;&#93;(n); }<br />&nbsp;<br />&nbsp; function repl($0,$1) {<br />&nbsp; &nbsp; switch ($1.toUpperCase()) {<br />&nbsp; &nbsp; &nbsp; case 'YYYY' : return lpad(y,p4);<br />&nbsp; &nbsp; &nbsp; case 'YY'&nbsp; &nbsp;: return (p2+y.toString()).slice(-2);<br />&nbsp; &nbsp; &nbsp; case 'Y'&nbsp; &nbsp; : return y.toString();<br />&nbsp; &nbsp; &nbsp; case 'MM'&nbsp; &nbsp;: return lpad(m+1,p2);<br />&nbsp; &nbsp; &nbsp; case 'M'&nbsp; &nbsp; : return (m+1).toString();<br />&nbsp; &nbsp; &nbsp; case 'DD'&nbsp; &nbsp;: return lpad(d,p2);<br />&nbsp; &nbsp; &nbsp; case 'D'&nbsp; &nbsp; : return d.toString();<br />&nbsp; &nbsp; &nbsp; case 'W'&nbsp; &nbsp; : return w.toString();<br />&nbsp; &nbsp; &nbsp; case 'HH'&nbsp; &nbsp;: return lpad(h,p2);<br />&nbsp; &nbsp; &nbsp; case 'H'&nbsp; &nbsp; : return h.toString();<br />&nbsp; &nbsp; &nbsp; case 'HH12' : return lpad(h12,p2);<br />&nbsp; &nbsp; &nbsp; case 'H12'&nbsp; : return h12.toString();<br />&nbsp; &nbsp; &nbsp; case 'NN'&nbsp; &nbsp;: return lpad(n,p2);<br />&nbsp; &nbsp; &nbsp; case 'N'&nbsp; &nbsp; : return n.toString();<br />&nbsp; &nbsp; &nbsp; case 'SS'&nbsp; &nbsp;: return lpad(s,p2);<br />&nbsp; &nbsp; &nbsp; case 'S'&nbsp; &nbsp; : return s.toString();<br />&nbsp; &nbsp; &nbsp; case 'FFF'&nbsp; : return lpad(f,p3);<br />&nbsp; &nbsp; &nbsp; case 'F'&nbsp; &nbsp; : return f.toString();<br />&nbsp; &nbsp; &nbsp; case 'AM'&nbsp; &nbsp;: return h&gt;=12 ? 'PM' : 'AM';<br />&nbsp; &nbsp; &nbsp; case 'PM'&nbsp; &nbsp;: return h&gt;=12 ? 'pm' : 'am';<br />&nbsp; &nbsp; &nbsp; case 'UMS'&nbsp; : return u.toString();<br />&nbsp; &nbsp; &nbsp; case 'USD'&nbsp; : return (u/1000).toString();<br />&nbsp; &nbsp; &nbsp; case 'UMD'&nbsp; : return (u/1000/60).toString();<br />&nbsp; &nbsp; &nbsp; case 'UHD'&nbsp; : return (u/1000/60/60).toString();<br />&nbsp; &nbsp; &nbsp; case 'UDD'&nbsp; : return (u/1000/60/60/24).toString();<br />&nbsp; &nbsp; &nbsp; case 'U'&nbsp; &nbsp; : return trunc(u/1000).toString();<br />&nbsp; &nbsp; &nbsp; case 'US'&nbsp; &nbsp;: return trunc(u/1000).toString();<br />&nbsp; &nbsp; &nbsp; case 'UM'&nbsp; &nbsp;: return trunc(u/1000/60).toString();<br />&nbsp; &nbsp; &nbsp; case 'UH'&nbsp; &nbsp;: return trunc(u/1000/60/60).toString();<br />&nbsp; &nbsp; &nbsp; case 'UD'&nbsp; &nbsp;: return trunc(u/1000/60/60/24).toString();<br />&nbsp; &nbsp; &nbsp; case 'ZZZZ' : return zs+lpad(za,p3);<br />&nbsp; &nbsp; &nbsp; case 'Z'&nbsp; &nbsp; : return z.toString();<br />&nbsp; &nbsp; &nbsp; case 'ZS'&nbsp; &nbsp;: return zs;<br />&nbsp; &nbsp; &nbsp; case 'ZH'&nbsp; &nbsp;: return lpad(trunc(za/60),p2);<br />&nbsp; &nbsp; &nbsp; case 'ZM'&nbsp; &nbsp;: return lpad(za%60,p2);<br />&nbsp; &nbsp; &nbsp; case 'ISOTS'&nbsp; : return ''+lpad(y,p4)+lpad(m+1,p2)+lpad(d,p2)+'T'+lpad(h,p2)+lpad(n,p2)+lpad(s,p2)+pp+lpad(f,p3)+zs+lpad(trunc(za/60),p2)+lpad(za%60,p2);<br />&nbsp; &nbsp; &nbsp; case 'ISODT'&nbsp; : return ''+lpad(y,p4)+lpad(m+1,p2)+lpad(d,p2);<br />&nbsp; &nbsp; &nbsp; case 'ISOTM'&nbsp; : return ''+lpad(h,p2)+lpad(n,p2)+lpad(s,p2)+pp+lpad(f,p3);<br />&nbsp; &nbsp; &nbsp; case 'ISOTZ'&nbsp; : return ''+zs+lpad(trunc(za/60),p2)+lpad(za%60,p2);<br />&nbsp; &nbsp; &nbsp; case 'ISO-TS' : return ''+lpad(y,p4)+pd+lpad(m+1,p2)+pd+lpad(d,p2)+'T'+lpad(h,p2)+pc+lpad(n,p2)+pc+lpad(s,p2)+pp+lpad(f,p3)+zs+lpad(trunc(za/60),p2)+pc+lpad(za%60,p2);<br />&nbsp; &nbsp; &nbsp; case 'ISO-DT' : return ''+lpad(y,p4)+pd+lpad(m+1,p2)+pd+lpad(d,p2);<br />&nbsp; &nbsp; &nbsp; case 'ISO-TM' : return ''+lpad(h,p2)+pc+lpad(n,p2)+pc+lpad(s,p2)+pp+lpad(f,p3);<br />&nbsp; &nbsp; &nbsp; case 'ISO-TZ' : return ''+zs+lpad(trunc(za/60),p2)+pc+lpad(za%60,p2);<br />&nbsp; &nbsp; &nbsp; case 'WEEKDAY': return weekday&#91;w&#93;;<br />&nbsp; &nbsp; &nbsp; case 'WKD'&nbsp; &nbsp; : return wkd&#91;w&#93;;<br />&nbsp; &nbsp; &nbsp; case 'MONTH'&nbsp; : return month&#91;m&#93;;<br />&nbsp; &nbsp; &nbsp; case 'MTH'&nbsp; &nbsp; : return mth&#91;m&#93;;<br />&nbsp; &nbsp; &nbsp; case '{'&nbsp; &nbsp; &nbsp; : return $1;<br />&nbsp; &nbsp; &nbsp; default&nbsp; &nbsp; &nbsp; &nbsp;: return $0;<br />&nbsp; &nbsp; }<br />&nbsp; }<br /><br />&nbsp; function getWmiDt( prop ) {<br />&nbsp; &nbsp; if (_g.wmi===undefined) {<br />&nbsp; &nbsp; &nbsp; var svcLoc = new ActiveXObject(&quot;WbemScripting.SWbemLocator&quot;);<br />&nbsp; &nbsp; &nbsp; _g.wmi = svcLoc.ConnectServer(&quot;.&quot;, &quot;root\\cimv2&quot;);<br />&nbsp; &nbsp; }<br />&nbsp; &nbsp; if (_g.wmiFile===undefined) {<br />&nbsp; &nbsp; &nbsp; _g.wmiFile = new Enumerator(_g.wmi.ExecQuery(<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &quot;Select * From &quot;+(_g.dirs?&quot;Win32_Directory&quot;:&quot;Cim_DataFile&quot;)<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;+&quot; Where Name = '&quot;+_g.file.Path.replace(/\\/g,&quot;\\\\&quot;).replace(/'/g,&quot;\\'&quot;)+&quot;'&quot;<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; )).item();<br />&nbsp; &nbsp; }<br />&nbsp; &nbsp; var wmiDt;<br />&nbsp; &nbsp; switch (prop.toLowerCase()) {<br />&nbsp; &nbsp; &nbsp; case 'c': wmiDt=_g.wmiFile.CreationDate; break;<br />&nbsp; &nbsp; &nbsp; case 'm': wmiDt=_g.wmiFile.LastModified; break;<br />&nbsp; &nbsp; &nbsp; case 'a': wmiDt=_g.wmiFile.LastAccessed; break;<br />&nbsp; &nbsp; &nbsp; default: return undefined;<br />&nbsp; &nbsp; }<br />&nbsp; &nbsp; var tz=Number(wmiDt.substr(22));<br />&nbsp; &nbsp; var dt = new Date(&nbsp; &nbsp; &nbsp;wmiDt.substr(0,4)+ps+wmiDt.substr(4,2)+ps+wmiDt.substr(6,2)<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;+sp+wmiDt.substr(8,2)+pc+wmiDt.substr(10,2)+pc+wmiDt.substr(12,2)<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;+sp+wmiDt.substr(21,1)+lpad(trunc(tz/60),p2)+lpad(tz%60,p2)<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;);<br />&nbsp; &nbsp; dt.setMilliseconds(Number(wmiDt.substr(15,3)));<br />&nbsp; &nbsp; return dt;<br />&nbsp; }<br /><br />}<br /><br />function attr(off) {<br />&nbsp; var a=_g.file.Attributes;<br />&nbsp; var o=off?off.substr(0,1):'';<br />&nbsp; return&nbsp; (a&amp;1&nbsp; &nbsp;?'R':o?o:'r')&nbsp; //Read only<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;+(a&amp;2&nbsp; &nbsp;?'H':o?o:'h')&nbsp; //Hidden<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;+(a&amp;4&nbsp; &nbsp;?'S':o?o:'s')&nbsp; //System<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;+(a&amp;32&nbsp; ?'A':o?o:'a')&nbsp; //Archive<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;+(a&amp;1024?'L':o?o:'l')&nbsp; //Link or Shortcut<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;+(a&amp;2048?'C':o?o:'c'); //Compressed<br />}<br /><br />function size(pad) {return lpad(_g.file.Size,pad);}<br /><br />function type(pad) {return rpad(_g.file.Type,pad);}<br /><br />function path(pad) {return rpad(_g.file.Path,pad);}<br /><br />function parent(pad) {return rpad(_g.file.ParentFolder.Path,pad);}<br /><br />function name(pad) {return rpad(_g.file.Name,pad);}<br /><br />function sPath(pad) {return rpad(_g.file.ShortPath,pad);}<br /><br />function sParent(pad) {return rpad(_g.file.ParentFolder.ShortPath,pad);}<br /><br />function sName(pad) {return rpad(_g.file.ShortName,pad);}<br /></code></pre></div><br /><br />Dave Benham</div>
			</div>
			<hr />
					<div class="post">
				<h3>Re: JREN.BAT - Rename files/folders using regular expression</h3>
				<div class="date">Posted: <strong>09 Dec 2014 23:34</strong></div>
				<div class="author">by <strong>dbenham</strong></div>
				<div class="content">I got a private message from Brinda stating that the WMI calls to get the file timestamps was not working on Win 2000. There is also the issue that the WMI calls are quite slow.<br /><br />So I added additional ts() dt: options to get FileSystemObject (FSO) timestamps instead of using WMI. This is much faster. There are two draw backs:<br /><br />- FSO timestamps are only to second accracy - they do not have milliseconds.<br />- FSO timestamps are locale dependent - the timestamp will not parse properly in some countries.<br /><br />The old WMI timestamps are accessed via dt:'created', dt:'modified', and dt:'accessed'.<br />The new FSO timestamps are accessed via dt:'fsoCreated', dt:'fsoModified', and dt:'fsoAccessed'.<br /><br />I updated both the prior post as well as the current post at the top to version 2.1.<br /><br /><br />Dave Benham</div>
			</div>
			<hr />
					<div class="post">
				<h3>Re: JREN.BAT - Rename files/folders using regular expression</h3>
				<div class="date">Posted: <strong>10 Dec 2014 07:36</strong></div>
				<div class="author">by <strong>dbenham</strong></div>
				<div class="content">I updated version 2.1 to 2.2 to squash another bug.<br /><br />At one point I had a /G option to make the Search global. I later opted to have all searches global, so I eliminated the /G option, but forgot to change my Search regex definition.<br /><br />Version 2.2 fixes the bug by making all searches global.<br /><br />Original line 684<br /><div class="codebox"><p>Code: <a href="#" onclick="selectCode(this); return false;">Select all</a></p><pre><code>&nbsp; &nbsp; &nbsp; &nbsp; search = BuildRegex( 'Search', args.Item(0), env('/G')?'g':'' + env('/I')?'i':'' ),<br /></code></pre></div><br />changed to <br /><div class="codebox"><p>Code: <a href="#" onclick="selectCode(this); return false;">Select all</a></p><pre><code>&nbsp; &nbsp; &nbsp; &nbsp; search = BuildRegex( 'Search', args.Item(0), env('/I')?'gi':'g' ),<br /></code></pre></div><br /><br />Dave Benham</div>
			</div>
			<hr />
					<div class="post">
				<h3>Re: JREN.BAT - Rename files/folders using regular expression</h3>
				<div class="date">Posted: <strong>13 Dec 2014 06:44</strong></div>
				<div class="author">by <strong>brinda</strong></div>
				<div class="content"><blockquote><div><cite>dbenham wrote:</cite>I got a private message from Brinda stating that the WMI calls to get the file timestamps was not working on Win 2000. There is also the issue that the WMI calls are quite slow.<br /><br />So I added additional ts() dt: options to get FileSystemObject (FSO) timestamps instead of using WMI. This is much faster. There are two draw backs:<br /><br />- FSO timestamps are only to second accracy - they do not have milliseconds.<br />- FSO timestamps are locale dependent - the timestamp will not parse properly in some countries.<br /><br />The old WMI timestamps are accessed via dt:'created', dt:'modified', and dt:'accessed'.<br />The new FSO timestamps are accessed via dt:'fsoCreated', dt:'fsoModified', and dt:'fsoAccessed'.<br /><br />I updated both the prior post as well as the current post at the top to version 2.1.<br /><br /><br />Dave Benham</div></blockquote><br /><br />dave, <br /><br />sorry for late reply. thanks for helping on this<br /><br />on win2000<br /><br />previous code<br /><div class="codebox"><p>Code: <a href="#" onclick="selectCode(this); return false;">Select all</a></p><pre><code>D:\test&gt;jren &quot;.*&quot; &quot;ts({dt:'modified',fmt:'{iso-dt} {iso-tm} {iso-tz}&nbsp; '})+attr()+size('&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;')+'&nbsp; '+path()&quot; /j /list /fm *.htm<br />Replace error: Invalid dt value</code></pre></div><br /><br />with the ammended code<br /><div class="codebox"><p>Code: <a href="#" onclick="selectCode(this); return false;">Select all</a></p><pre><code>D:\test&gt;jren &quot;.*&quot; &quot;ts({dt:'fsomodified',fmt:'{iso-dt} {iso-tm} {iso-tz}&nbsp; '})+attr()+size('&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;')+'&nbsp; '+path()&quot; /j /list /fm *.htm<br />2014-12-12 20:12:18.000 +08:00&nbsp; rhsAlc&nbsp; &nbsp; 20684&nbsp; D:\test\1.htm2014-12-12 20:12:18.000 +08:00&nbsp; rhsAlc&nbsp; &nbsp; 20684&nbsp; D:\test\1.htm<br />2014-12-12 20:08:28.000 +08:00&nbsp; rhsAlc&nbsp; &nbsp; 16834&nbsp; D:\test\10.htm2014-12-12 20:08:28.000 +08:00&nbsp; rhsAlc&nbsp; &nbsp; 16834&nbsp; D:\test\10.htm<br />2014-12-12 20:08:16.000 +08:00&nbsp; rhsAlc&nbsp; &nbsp; 12917&nbsp; D:\test\11.htm2014-12-12 20:08:16.000 +08:00&nbsp; rhsAlc&nbsp; &nbsp; 12917&nbsp; D:\test\11.htm<br />2014-12-12 20:08:06.000 +08:00&nbsp; rhsAlc&nbsp; &nbsp; 15085&nbsp; D:\test\12.htm2014-12-12 20:08:06.000 +08:00&nbsp; rhsAlc&nbsp; &nbsp; 15085&nbsp; D:\test\12.htm<br />2014-12-12 20:07:52.000 +08:00&nbsp; rhsAlc&nbsp; &nbsp; 14955&nbsp; D:\test\13.htm2014-12-12 20:07:52.000 +08:00&nbsp; rhsAlc&nbsp; &nbsp; 14955&nbsp; D:\test\13.htm</code></pre></div></div>
			</div>
			<hr />
					<div class="post">
				<h3>Re: JREN.BAT - Rename files/folders using regular expression</h3>
				<div class="date">Posted: <strong>13 Dec 2014 07:53</strong></div>
				<div class="author">by <strong>dbenham</strong></div>
				<div class="content">Thanks brinda.<br /><br />My example was wrong. The &quot;.*&quot; search term matches both the entire line, plus the position at the end of the line, so it prints out the information twice.<br /><br />The search term should be changed to &quot;^.*&quot;, and then it works perfectly.<br /><br />The old search term used to work until version 2.2 when I implicitly added the global attribute to the regex search. A Global search was my original intent all along.<br /><br />I've updated the examples throughout the thread to compensate for the corrected behavior.<br /><br /><br />Dave Benham</div>
			</div>
			<hr />
					<div class="post">
				<h3>Re: JREN.BAT - Rename files/folders using regular expression</h3>
				<div class="date">Posted: <strong>13 Dec 2014 09:20</strong></div>
				<div class="author">by <strong>Squashman</strong></div>
				<div class="content">Ugh. Shouldn't have to support 6 MS operating systems.</div>
			</div>
			<hr />
					<div class="post">
				<h3>Re: JREN.BAT - Rename files/folders using regular expression</h3>
				<div class="date">Posted: <strong>27 Apr 2015 12:24</strong></div>
				<div class="author">by <strong>foxidrive</strong></div>
				<div class="content">Dave, have ya got a second to think about this one?<br /><br />A task is to basically take 5 filenames at a time to echo into a file, and run a task - then repeat with the next five files.<br /><br />I aimed to use a padded number - purely for cosmetic reasons in the output set of filenames -<br />and I was wondering if JREN has the ability to do both these things? <br /><br />The task is listed here:<br /><!-- m --><a class="postlink" href="http://ss64.org/viewtopic.php?pid=8345#p8345">http://ss64.org/viewtopic.php?pid=8345#p8345</a><!-- m --><br /><br />I'm trying to avoid using delayed expansion and stacks of calls and lots of manipulating,<br />and the jscript tools are so much more robust, and easier on the code.<br /><br /><br />I looked at Findrepl and thought of using the errorlevel to calculate where the next set of filenames was to start from but the /o:s:e doesn't seem to support a calculation - and as above I'm always trying to avoid delayed expansion.<br /><br />If you're reading Antonio, did I miss a way to do it with Findrepl?</div>
			</div>
			<hr />
					<div class="post">
				<h3>Re: JREN.BAT - Rename files/folders using regular expression</h3>
				<div class="date">Posted: <strong>27 Apr 2015 14:50</strong></div>
				<div class="author">by <strong>dbenham</strong></div>
				<div class="content">I don't see a simple solution using JREN, but it is fairly simple with JREPL. I've posted a solution at SS64.<br /><br /><br />Dave Benham</div>
			</div>
			<hr />
					<div class="post">
				<h3>Re: JREN.BAT - Rename files/folders using regular expression</h3>
				<div class="date">Posted: <strong>29 Apr 2015 09:02</strong></div>
				<div class="author">by <strong>foxidrive</strong></div>
				<div class="content">Followup to your post at ss64, Dave.</div>
			</div>
			<hr />
			</div>

	<div id="page-footer" class="page-footer">
		<div class="page-number">All times are <span title="UTC-6">UTC-06:00</span><br />Page <strong>1</strong> of <strong>4</strong></div>
		<div class="copyright">Powered by phpBB&reg; Forum Software &copy; phpBB Limited<br />https://www.phpbb.com/</div>
	</div>
</div>

</body>

<!-- Mirrored from www.dostips.com/forum/viewtopic.php?f=3&t=6081&view=print by HTTrack Website Copier/3.x [XR&CO'2014], Fri, 19 Oct 2018 05:00:10 GMT -->
</html>
