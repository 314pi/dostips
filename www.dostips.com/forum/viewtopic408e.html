<!DOCTYPE html>
<html dir="ltr" lang="en-gb">

<!-- Mirrored from www.dostips.com/forum/viewtopic.php?f=3&t=5819&start=15&view=print by HTTrack Website Copier/3.x [XR&CO'2014], Fri, 19 Oct 2018 07:05:10 GMT -->
<!-- Added by HTTrack --><meta http-equiv="content-type" content="text/html;charset=UTF-8" /><!-- /Added by HTTrack -->
<head>
<meta charset="utf-8" />
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="robots" content="noindex" />

<title>DosTips.com &bull; Dos Batch Math Library - Page 2</title>

<link href="styles/AllanStyle-SUBSILVER/theme/print.css" rel="stylesheet">
</head>
<body id="phpbb">
<div id="wrap" class="wrap">
	<a id="top" class="top-anchor" accesskey="t"></a>

	<div id="page-header">
		<h1>DosTips.com</h1>
		<p>A Forum all about DOS Batch<br /><a href="index-2.html">https://www.dostips.com/forum/</a></p>

		<h2>Dos Batch Math Library</h2>
		<p><a href="viewtopic8d84.html?f=3&amp;t=5819">https://www.dostips.com/forum/viewtopic.php?f=3&amp;t=5819</a></p>
	</div>

	<div id="page-body" class="page-body">
		<div class="page-number">Page <strong>2</strong> of <strong>4</strong></div>
					<div class="post">
				<h3>Re: Dos Batch Math Library</h3>
				<div class="date">Posted: <strong>11 Aug 2014 07:08</strong></div>
				<div class="author">by <strong>dbenham</strong></div>
				<div class="content">Done - post has been edited <img class="smilies" src="images/smilies/icon_smile.gif" alt=":)" title="Smile" /><br /><br /><br />Also, abs() of a 32bit integer is trivial to implement. Here is a version.<br /><div class="codebox"><p>Code: <a href="#" onclick="selectCode(this); return false;">Select all</a></p><pre><code>@echo off<br /><br />:ABS&nbsp; InExpr&nbsp; &#91;OutVar&#93;<br />::<br />:: Compute the absolute value of expression InExpr<br />:: and store the result in variable OutVar.<br />:: Write the result to stdout if OutVar not specified.<br />::<br />:: InExpr may be a valid SET /A mathematical expression.<br />::<br />:: An error is raised if an attempt is made to get the<br />:: absolute value of the smallest negative integer.<br />::<br />setlocal<br />set /a &quot;rtn=%~1&quot;<br />set /a &quot;rtn=%rtn:-=%&quot; || exit /b<br />endlocal &amp; if &quot;%~2&quot; equ &quot;&quot; (echo %rtn%) else set &quot;%~2=%rtn%&quot;<br />exit /b<br /></code></pre></div></div>
			</div>
			<hr />
					<div class="post">
				<h3>Re: Dos Batch Math Library</h3>
				<div class="date">Posted: <strong>13 Aug 2014 07:57</strong></div>
				<div class="author">by <strong>einstein1969</strong></div>
				<div class="content">well done. Soon i propose an alternate method (faster) for the sqrt.<br /><br />Francesco Poscetti</div>
			</div>
			<hr />
					<div class="post">
				<h3>Re: Dos Batch Math Library</h3>
				<div class="date">Posted: <strong>17 Aug 2014 15:45</strong></div>
				<div class="author">by <strong>trebor68</strong></div>
				<div class="content">Calculating Square Root<br /><br />Here the mathematic rules:<br /><ul>(a + b)^2 = <span style="color: #FF0000">a^2</span> + <span style="color: #40BF00">2ab + b^2</span><br />= <span style="color: #FF0000">a^2</span> + <span style="color: #40BF00">(2a + b) * b</span><br /><br />(a + b + c)^2 = <span style="color: #FF0000">a^2</span> + <span style="color: #40BF00">2ab + b^2</span> + <span style="color: #BF8000">2ac + 2bc + c^2</span><br />= <span style="color: #FF0000">a^2</span> + <span style="color: #40BF00">(2a + b) * b</span> + <span style="color: #BF8000">(2a + 2b + c) * c</span><br /></ul><br />Here my code<br /><div class="codebox"><p>Code: <a href="#" onclick="selectCode(this); return false;">Select all</a></p><pre><code>@echo off<br />echo Square Root<br />set para=%1<br />if %1# equ # (echo ERROR no number or negativ number) &amp; echo. &amp; goto :eof<br />if %1 lss 0 (echo ERROR no number or negativ number) &amp; echo. &amp; goto :eof<br />if %1 equ 0 echo sqrt(0) = 0 &amp; goto :eof<br /><br />set result=0<br />set var2=%para%<br />set &quot;hvar= &quot;<br />:bnum<br />set /a var1=&quot;var2 %% 100&quot;, var2= var2 / 100<br />set hvar=%var1% %hvar%<br />if %var2% geq 1 goto :bnum<br />call :wurzelber %hvar%<br />echo sqrt(%para%) = %result%<br />goto :eof<br /><br />:wurzelber<br />rem echo %*<br />set digit=1<br />set zahl2=0<br />set zahl1=%1<br />for %%a in (1 4 9 16 25 36 49 64 81) do if %zahl1% geq %%a set /a zahl2+=1<br />set /a zahl1=zahl1 - zahl2*zahl2<br /><br />:next1<br />if %2# neq # (set zahln=%2) else (set /a zahln=0, digit*=10)<br />set /a zahl1=zahl1 * 100 + zahln, zahlh = zahl1 / zahl2 / 20, zahl3 = (20 * zahl2 + zahlh) * zahlh<br /><br />if %zahl1% lss %zahl3% set /a zahlh-=1, zahl3 = (20 * zahl2 + zahlh) * zahlh<br /><br />set /a zahl2 = 10 * zahl2 + zahlh, zahl1 -= zahl3<br />shift /2<br /><br />if %digit% equ 1 if %zahl1% equ 0 (set result=%zahl2%) &amp; goto :eof<br />if %zahl1% geq 1000000 (<br />&nbsp; set /a zahla = zahl2 / digit, zahlb = &quot;(zahl2 %% digit) + digit&quot;<br />) &amp; (set result=!zahla!.!zahlb:~1!) &amp; goto :eof<br />goto :next1</code></pre></div></div>
			</div>
			<hr />
					<div class="post">
				<h3>Re: Dos Batch Math Library</h3>
				<div class="date">Posted: <strong>18 Aug 2014 09:32</strong></div>
				<div class="author">by <strong>dbenham</strong></div>
				<div class="content">@tebor68 - I'm afraid that is a significant step backwards.<br /><br />- You forgot SetLocal EnableDelayedExpansion<br /><br />- It fails with perfect squares: 1, 4, 9, 25, etc.<br /><br />- The last decimal digit(s) are not always correct<br /><br />- Using test values of 11, 110, 1100, 11000, 110000, 1100000, 11000000, 110000000, 1100000000, I find it to be 75% slower than my most recent version<br /><br /><br />Dave Benham</div>
			</div>
			<hr />
					<div class="post">
				<h3>Re: Dos Batch Math Library</h3>
				<div class="date">Posted: <strong>19 Aug 2014 02:01</strong></div>
				<div class="author">by <strong>trebor68</strong></div>
				<div class="content">I have changed the code. <br />Now the pure square numbers less than 100 are also correct. <br />The result has now less one decimal place, but this is rounded.<br /><br /><div class="codebox"><p>Code: <a href="#" onclick="selectCode(this); return false;">Select all</a></p><pre><code>@echo off<br />SetLocal EnableDelayedExpansion<br />echo Square Root<br />set para=%1<br />if %1# equ # (echo ERROR no number or negativ number) &amp; echo. &amp; goto :eof<br />if %1 lss 0 (echo ERROR no number or negativ number) &amp; echo. &amp; goto :eof<br />if %1 equ 0 echo sqrt(0) = 0 &amp; goto :eof<br /><br />set result=0<br />set var2=%para%<br />set &quot;hvar= &quot;<br />:bnum<br />set /a var1=&quot;var2 %% 100&quot;, var2= var2 / 100<br />set hvar=%var1% %hvar%<br />if %var2% geq 1 goto :bnum<br />call :wurzelber %hvar%<br />echo sqrt(%para%) = %result%<br />goto :eof<br /><br />:wurzelber<br />rem echo %*<br />set digit=1<br />set zahl2=0<br />set zahl1=%1<br />for %%a in (1 4 9 16 25 36 49 64 81) do if %zahl1% geq %%a set /a zahl2+=1<br />set /a zahl1=zahl1 - zahl2*zahl2<br />if %2# equ # if %zahl1% equ 0 (set result=%zahl2%) &amp; goto :eof<br /><br />:next1<br />if %2# neq # (set zahln=%2) else (set /a zahln=0, digit*=10)<br />set /a zahl1=zahl1 * 100 + zahln, zahlh = zahl1 / zahl2 / 20, zahl3 = (20 * zahl2 + zahlh) * zahlh<br /><br />if %zahl1% lss %zahl3% set /a zahlh-=1, zahl3 = (20 * zahl2 + zahlh) * zahlh<br /><br />set /a zahl2 = 10 * zahl2 + zahlh, zahl1 -= zahl3<br />shift /2<br /><br />if %digit% equ 1 if %zahl1% equ 0 (set result=%zahl2%) &amp; goto :eof<br />if %zahl1% geq 1000000 (<br />&nbsp; set /a zahla = zahl2 / digit, zahlb = &quot;((zahl2 + 5) %% digit) + digit&quot;<br />) &amp; (set result=!zahla!.!zahlb:~1,-1!) &amp; goto :eof<br />goto :next1</code></pre></div></div>
			</div>
			<hr />
					<div class="post">
				<h3>Re: Dos Batch Math Library</h3>
				<div class="date">Posted: <strong>19 Aug 2014 05:14</strong></div>
				<div class="author">by <strong>dbenham</strong></div>
				<div class="content">@trebor68<br /><br />Perfect square multiples of 100 are wrong.<br /><br />Examples:<br />10000, 1000000 both compute as 10<br />40000, 4000000 both compute as 20<br /><br /><br />Dave Benham</div>
			</div>
			<hr />
					<div class="post">
				<h3>Re: Dos Batch Math Library</h3>
				<div class="date">Posted: <strong>19 Aug 2014 08:18</strong></div>
				<div class="author">by <strong>trebor68</strong></div>
				<div class="content">@dbenham<br /><br />Thank you.<br />The code has previously worked well up to this point. But after the code change I have probably not tested again this part.<br /><br /><br />Change the condition for the perfect squares greater 100.<br /><br />Also change condition for the not perfect squares (now checked with variable zahl2).<br />The result with 8 significant digits, last digit is rounded.<br /><br /><div class="codebox"><p>Code: <a href="#" onclick="selectCode(this); return false;">Select all</a></p><pre><code>@echo off<br />SetLocal EnableDelayedExpansion<br />echo Square Root<br />set para=%1<br />if %1# equ # (echo ERROR no number or negativ number) &amp; echo. &amp; goto :eof<br />if %1 lss 0 (echo ERROR no number or negativ number) &amp; echo. &amp; goto :eof<br />if %1 equ 0 echo sqrt(0) = 0 &amp; goto :eof<br /><br />set result=0<br />set var2=%para%<br />set &quot;hvar= &quot;<br />:bnum<br />set /a var1=&quot;var2 %% 100&quot;, var2= var2 / 100<br />set hvar=%var1% %hvar%<br />if %var2% geq 1 goto :bnum<br />call :wurzelber %hvar%<br />echo sqrt(%para%) = %result%<br />goto :eof<br /><br />:wurzelber<br />rem echo %*<br />set digit=1<br />set zahl2=0<br />set zahl1=%1<br />for %%a in (1 4 9 16 25 36 49 64 81) do if %zahl1% geq %%a set /a zahl2+=1<br />set /a zahl1=zahl1 - zahl2*zahl2<br />if %2# equ # if %zahl1% equ 0 (set result=%zahl2%) &amp; goto :eof<br /><br />:next1<br />if %2# neq # (set zahln=%2) else (set /a zahln=0, digit*=10)<br />set /a zahl1=zahl1 * 100 + zahln, zahlh = zahl1 / zahl2 / 20, zahl3 = (20 * zahl2 + zahlh) * zahlh<br /><br />if %zahl1% lss %zahl3% set /a zahlh-=1, zahl3 = (20 * zahl2 + zahlh) * zahlh<br /><br />set /a zahl2 = 10 * zahl2 + zahlh, zahl1 -= zahl3<br />shift /2<br /><br />if %digit% equ 1 if %zahl1% equ 0 if %2# equ # (set result=%zahl2%) &amp; goto :eof<br /><br />rem break calc when: zahl2 GEQ 100,000,000&nbsp; ##&nbsp; result with 8 significant digits, last digit is rounded<br />if %zahl2% geq 100000000 (<br />&nbsp; set /a zahla = &quot;(zahl2 + 5) / digit&quot;, zahlb = &quot;((zahl2 + 5) %% digit) + digit&quot;<br />) &amp; (set result=!zahla!.!zahlb:~1,-1!) &amp; goto :eof<br />goto :next1</code></pre></div></div>
			</div>
			<hr />
					<div class="post">
				<h3>Re: Dos Batch Math Library</h3>
				<div class="date">Posted: <strong>02 Sep 2014 14:47</strong></div>
				<div class="author">by <strong>trebor68</strong></div>
				<div class="content">Here a batch file to calculate the Square root.<br />The steps correspond to the calculation with decimal numbers, but here the calculations on binary numbers are optimized.<br /><br />BATCH <span style="color: #FF0000">value</span><br />BATCH <span style="color: #808000">value IEEE</span><br /><br /><span style="color: #FF0000">value</span><br />&quot;Value&quot; is an integer from 0 through 2147483647.<br />The result is calculated to four decimal places.<br /><br /><span style="color: #808000">value IEEE</span><br />&quot;Value&quot; is a number in floating-point representation.<br />For some values ​​of all results are not yet available. These values ​​are quite small numbers, the really big numbers and the number 0.<br /><br /><br />EDIT<br />The revision of the values ​​&quot;inf&quot; and &quot;NaN&quot; incorporated.<br />The results of the values ​​greater than zero and less 2^-127  (1.1754944 e-38; IEEE 0x00800000) incorrect.<br /><br /><div class="codebox"><p>Code: <a href="#" onclick="selectCode(this); return false;">Select all</a></p><pre><code>@echo off<br />SetLocal EnableExtensions <br />:: EnableDelayedExpansion<br />echo Square Root (version binary^)<br />echo.<br />set &quot;IEEE=&quot;<br />if /i &quot;%2&quot; equ &quot;IEEE&quot; (set IEEE=IEEE) &amp; goto :ieee1<br /><br />set /a para=%1 &gt;nul 2&gt;&amp;1<br />if errorlevel 1 (echo ERROR - wrong value:&nbsp; &nbsp;%1) &amp; goto :eof<br /><br />if %para%#==# (echo ERROR - no parameter) &amp; goto :eof<br />if %para% lss 0 (echo ERROR - no negative numbers) &amp; goto :eof<br />if %para% equ 0 (echo SQRT(%para%^) = 0) &amp; goto :eof<br /><br />rem&nbsp; ##&nbsp; 33222222 22221111 11111100 00000000&nbsp; &nbsp;###&nbsp; &nbsp;33222222 22221111 11111100 00000000<br />rem&nbsp; ##&nbsp; 10987654 32109876 54321098 76543210&nbsp; &nbsp;###&nbsp; &nbsp;10987654 32109876 54321098 76543210&nbsp; &nbsp;Bits in variable num and num2<br />rem&nbsp; ##&nbsp; lxxxxxxx xxxxxxxx xxxxxxxx xxxxxxxx&nbsp; &nbsp;###&nbsp; &nbsp;iixxxxxx xxxxxxxx xxxxxxxx xxxxxxxx&nbsp; &nbsp;Integer value; l - not used (minus bit); ii - used when num2 less than 0<br />rem&nbsp; ##&nbsp; leeeeeee exxxxxxx xxxxxxxx xxxxxxxx&nbsp; &nbsp;###&nbsp; &nbsp;iixxxxxx xxxxxxxx xxxxxxxx xxxxxxxx&nbsp; &nbsp;IEEE value; l - not used (minus bit); e - exponent; ii - used when num2 less than 0<br />rem&nbsp; result of Integer value&nbsp; &nbsp; &nbsp; :&nbsp; (1098 7654 3210 9876&nbsp; 543 2109 8765 4321) * 2^-15&nbsp; &nbsp;&lt;==&gt;&nbsp; result with max 31 bits<br />rem&nbsp; result of floting point value:&nbsp; (&nbsp; &nbsp; &nbsp;7654 3210 9876&nbsp; 543 2109 8765 4321) * 2^-15&nbsp; &nbsp;&lt;==&gt;&nbsp; any result with 27 bits<br />rem&nbsp; IEEE calcuting with the xxx and bit 23 (in variable num): 2^23 + xxx<br /><br />rem bit = max 15 in 32-Bit-system; Integer (max = 2147483647)<br />:ieee1<br />set /a res = 1, bit = 15, num = %1, &quot;block = (1 &lt;&lt; (2 * bit))&quot;, blplus = 0x40000000, num2 = 0, ERRcode = -1<br /><br /><br />if defined IEEE set /a &quot;sgn = (%1 &gt;&gt; 31) &amp; 1&quot;, &quot;exp = (%1 &amp; 0x7F800000) &gt;&gt; 23&quot;, &quot;man = %1 &amp; 0x7FFFFF&quot;<br /><br />rem test value with special values: NaN, inf and 0<br />rem&nbsp; &nbsp;SQRT(NaN) and SQRT(-NaN)&nbsp; --&nbsp; not possible then value is not a number<br />rem&nbsp; &nbsp;SQRT(inf) and SQRT(-inf)&nbsp; --&nbsp; not possible then value is infinity<br />rem&nbsp; &nbsp;SQRT(0)&nbsp; &nbsp;and SQRT(-0)&nbsp; &nbsp; --&nbsp; definated as Zero&nbsp; --&nbsp; definated: SQRT(-0) = -0<br />if defined IEEE (<br />&nbsp; if %1 equ 0x7FFFFFFF set /a result2 = 0x7FFFFFFF, ERRcode = 1<br />&nbsp; if %1 equ 0xFFFFFFFF set /a result2 = 0xFFFFFFFF, ERRcode = 1<br />&nbsp; if %1 equ 0x7F800000 set /a result2 = 0x7FFFFFFF, ERRcode = 2<br />&nbsp; if %1 equ 0xFF800000 set /a result2 = 0xFFFFFFFF, ERRcode = 2<br />&nbsp; if %1 equ 0x00000000 set /a result2 = 0x00000000, ERRcode = 0<br />&nbsp; if %1 equ 0x80000000 set /a result2 = 0x80000000, ERRcode = 0<br />)<br />if %ERRcode% neq -1 goto :next5<br /><br />if defined IEEE set /a&nbsp; &quot;num = man | 0x800000&quot;<br />if defined IEEE set /a&nbsp; para2=num, exp2 = exp - 127, sgn2 = -1 * sgn<br />:: if defined IEEE (echo IEEE&nbsp; sgn = %sgn%&nbsp; ==^&gt;&nbsp; %sgn2%&nbsp; #&nbsp; exp = %exp%&nbsp; ==^&gt;&nbsp; %exp2%&nbsp; #&nbsp; man = %man%&nbsp; ==^&gt;&nbsp; %num%) &amp; echo.<br /><br />rem WHEN exp = 2n+1 IS num = 1.xxx * 2^23 THEN exp ==&gt; 2n TO num ==&gt; 1x.xxx * 2^22<br />if defined IEEE set /a &quot;hvar = exp &amp; 1&quot;, &quot;num2 = hvar * (num &amp; 1) * 0x20000000&quot;, &quot;num = num &gt;&gt; (hvar &amp; 1)&quot;<br />:: if defined IEEE echo calculating with: num = %num%&nbsp; #&nbsp; num2 = %num2%&nbsp; #&nbsp; exph = %exph% + 127 (testen^)<br /><br />if defined IEEE set /a&nbsp; exph = (exp+1) / 2 + 63 - 127<br /><br />rem&nbsp; &nbsp;SQRT(-xxx)&nbsp; --&nbsp; SQRT from negative numbers not possible<br />if defined IEEE if &quot;%sgn%&quot; equ &quot;1&quot; (set /a result2 = 0x7FFFFFFF, ERRcode = 3) &amp; goto :next5<br /><br />:next1<br />if %block% gtr %num% (set /a &quot;block &gt;&gt;= 2&quot;, bit -= 1) &amp; goto :next1<br /><br />rem first one or two bits; xx * 4^bit, with: 1 LEQ xx LSS 4; bith: bits in front of the point (comma)<br />set /a num = num - block, bith = bit<br /><br />:next2<br />if %bit% equ 0 goto :next3<br /><br />set /a &quot;block &gt;&gt;= 2&quot;, bit -= 1, &quot;vh = ((res &lt;&lt; 2) + 1) &lt;&lt; (2 * bit)&quot;<br />if %num% geq %vh% (<br />&nbsp; set /a num -= vh, &quot;res = (res &lt;&lt; 1) + 1&quot;<br />) else set /a &quot;res &lt;&lt;= 1&quot;<br />goto :next2<br /><br />:next3<br />rem calculating bits after the point <br />:: echo SQRT(%para%^) = %res%.xxxx<br />:: echo.<br /><br />:next4<br />set /a bit -= 1, &quot;vh = (res &lt;&lt; 2) + 1&quot;, &quot;vh1 = vh &gt;&gt; (-2 * bit)&quot;, &quot;vh2 = (vh &amp; ((1 &lt;&lt; (-2 * bit)) - 1)) &lt;&lt; (30 + 2 * bit)&quot;, hvar = 0<br /><br />if %num% gtr %vh1% set hvar=2<br />if %num% equ %vh1% if %num2% gtr %vh2% set hvar=1<br />:: if %num% lss %vh1% echo ###&nbsp; num kleiner vh1&nbsp; ###<br /><br />if %hvar% equ 2 set /a num2 -= vh2, &quot;num -= vh1 - (num2 &gt;&gt; 31)&quot;, &quot;num2 -= (num2 &gt;&gt; 31) * blplus&quot;, &quot;res = (res &lt;&lt; 1) + 1&quot;<br />if %hvar% equ 1 set /a num = 0, num2 -= vh2, &quot;res = (res &lt;&lt; 1) + 1&quot;<br />if %hvar% equ 0 set /a &quot;res &lt;&lt;= 1&quot;<br /><br />if %bit% gtr -15 goto :next4<br /><br />:: echo SQRT(%para%^) = %res% * 2^^(%exph%-15)&nbsp; &nbsp; &nbsp;(%bith%+1 digits point 15 digit binary^)<br />:: echo.<br /><br />rem convert to decimal value<br />set /a &quot;r0 = res &gt;&gt; 15&quot;, &quot;rr = 1000 * (res &amp; 0x7fff)&quot;, &quot;r1 = rr &gt;&gt; 15&quot;, &quot;rr = 1000 * (rr &amp; 0x7fff)&quot;, &quot;r2 = rr &gt;&gt; 15&quot;, rr = 10000 + 10 * r1 + (r2 + 50) / 100<br />set result=%r0%.%rr:~-4%<br />if not defined IEEE echo SQRT(%para%^) = %result%<br /><br />:: set /a &quot;rest = res &amp; 7&quot;<br />:: echo Rest = %rest% / 8&nbsp; &nbsp;#&nbsp; &nbsp;num = %num%&nbsp; #&nbsp; num2 = %num2%&nbsp; #&nbsp; bith = %bith%<br /><br />set /a &quot;resieee = ((res + 0) &gt;&gt; 3) ^0x800000&quot;, exph = exph + 127<br />:: if defined IEEE echo.<br />:: if defined IEEE echo man = %resieee%&nbsp; #&nbsp; exp = %exph%<br />if defined IEEE set /a &quot;result2 = (sgn &lt;&lt; 31) | (exph &lt;&lt; 23) | resieee&quot;<br /><br />:next5<br />if defined IEEE (echo Result in IEEE = %result2%) &amp; echo.<br />if defined IEEE if %ERRcode% equ 1 echo&nbsp; ERROR: not possible then value is not a number<br />if defined IEEE if %ERRcode% equ 2 echo&nbsp; ERROR: not possible then value is infinity<br />if defined IEEE if %ERRcode% equ 3 echo&nbsp; ERROR: SQRT from negative numbers not possible<br /><br />EndLocal &amp; (set SQRT=%result%) &amp; set ISQRT=%result2%<br /></code></pre></div><br /><br /><br />The calculating of the reciprocal Sqaure root can see in this batch.<br /><div class="codebox"><p>Code: <a href="#" onclick="selectCode(this); return false;">Select all</a></p><pre><code>@echo off<br />SetLocal EnableExtensions<br />echo Reciprocal Square Root (version IEEE^)<br />echo.<br />set intnum=3<br /><br />:: load all macros, and exit if it has failed for whatever reasons<br />call &quot;loadFloat.bat&quot;<br />if errorLevel 1 exit /b 1<br /><br />:: use the macros (names are similar to the function names)<br />for %%a in (operand1 operand2 result string) do set &quot;%%~a=&quot;<br /><br /><br />set /a half=1056964608, threehalf=1069547520<br /><br />:: set xstr=15625e-5<br />:: set xstr=25<br /><br />set xstr=%1<br />%$str2float% &quot;%xstr%&quot; x<br /><br />:: echo Eingabewert x: %xstr%&nbsp; &nbsp;#&nbsp; dec: %x%<br />:: echo.<br />set /a &quot;y_n = 0x5f3759df - (x &gt;&gt; 1)&quot;<br />%$floatmul% %x% %half% x2<br />set result=%y_n%<br /><br />:next<br />set y_n=%result%<br />%$floatmul% %y_n% %y_n% y_n2<br />%$floatmul% %x2% %y_n2% zn<br />%$floatsub% %threehalf% %zn% zn<br />%$floatmul% %zn% %y_n% result<br /><br />:: %$float2str% %result% string<br />:: echo Zwischenergebnis : %string%<br /><br />set /a intnum -= 1<br />if not %intnum% equ 0 goto :next<br /><br />echo Ergebnis result&nbsp; : dec %result%<br />echo.<br />%$float2str% %result% string<br />echo Endergebnis&nbsp; &nbsp; &nbsp; : %string%<br />EndLocal</code></pre></div></div>
			</div>
			<hr />
					<div class="post">
				<h3>Re: Dos Batch Math Library</h3>
				<div class="date">Posted: <strong>13 Nov 2015 11:08</strong></div>
				<div class="author">by <strong>einstein1969</strong></div>
				<div class="content">Hi,<br /><br />I'm going to optimize the 32 bit Integer SQRT<br /><br />This trick down the maximum iteration from 20 to <strong class="text-strong">10</strong>, I think that I <strong class="text-strong">doubled</strong> the speed.<br /><br />The idea is to use <a href="viewtopiced5f.html?f=3&amp;t=3493" class="postlink">this trick</a> for go down<br /><br /><div class="codebox"><p>Code: <a href="#" onclick="selectCode(this); return false;">Select all</a></p><pre><code>@echo off<br />setlocal EnableDelayedExpansion<br /><br />Echo Partition the 32bit. Use 512 or 1024 guess!<br /><br />Set /a N=1<br />For /L %%N in (1,1,10) do (<br />&nbsp; call :sqrt N<br />&nbsp; set /A N=N*10<br />&nbsp; pause<br />)<br />rem MaxINT<br />call :sqrt 65536*32768-1<br />pause<br />exit /b<br /><br />:sqrt<br />set /A N=%1<br />if !N! neq 0 (<br /><br />&nbsp; set /A guess=1024, iter=0, x=guess &amp; rem max 10 iteration<br />&nbsp; For /L %%I in (1,1,10) do (<br /><br />&nbsp; &nbsp; set /A &quot;x=(N/x+x)/2, iter+=1&quot;<br />&nbsp; &nbsp; echo Sqrt(%N%^)=!x!&nbsp; Iter:!iter!<br />&nbsp; )<br />)<br />exit/b<br /></code></pre></div><br /><br />@trebor68<br />Very nice work on IEEE sqrt  <img class="smilies" src="images/smilies/icon_cool.gif" alt="8)" title="Cool" /><br /><br />EDIT:<br />output:<br /><div class="codebox"><p>Code: <a href="#" onclick="selectCode(this); return false;">Select all</a></p><pre><code>Partition the 32bit. Use 512 or 1024 guess<br />Sqrt(1)=512&nbsp; Iter:1<br />Sqrt(1)=256&nbsp; Iter:2<br />Sqrt(1)=128&nbsp; Iter:3<br />Sqrt(1)=64&nbsp; Iter:4<br />Sqrt(1)=32&nbsp; Iter:5<br />Sqrt(1)=16&nbsp; Iter:6<br />Sqrt(1)=8&nbsp; Iter:7<br />Sqrt(1)=4&nbsp; Iter:8<br />Sqrt(1)=2&nbsp; Iter:9<br />Sqrt(1)=1&nbsp; Iter:10<br />Premere un tasto per continuare . . .<br />Sqrt(10)=512&nbsp; Iter:1<br />Sqrt(10)=256&nbsp; Iter:2<br />Sqrt(10)=128&nbsp; Iter:3<br />Sqrt(10)=64&nbsp; Iter:4<br />Sqrt(10)=32&nbsp; Iter:5<br />Sqrt(10)=16&nbsp; Iter:6<br />Sqrt(10)=8&nbsp; Iter:7<br />Sqrt(10)=4&nbsp; Iter:8<br />Sqrt(10)=3&nbsp; Iter:9<br />Sqrt(10)=3&nbsp; Iter:10<br />Premere un tasto per continuare . . .<br />Sqrt(100)=512&nbsp; Iter:1<br />Sqrt(100)=256&nbsp; Iter:2<br />Sqrt(100)=128&nbsp; Iter:3<br />Sqrt(100)=64&nbsp; Iter:4<br />Sqrt(100)=32&nbsp; Iter:5<br />Sqrt(100)=17&nbsp; Iter:6<br />Sqrt(100)=11&nbsp; Iter:7<br />Sqrt(100)=10&nbsp; Iter:8<br />Sqrt(100)=10&nbsp; Iter:9<br />Sqrt(100)=10&nbsp; Iter:10<br />Premere un tasto per continuare . . .<br />Sqrt(1000)=512&nbsp; Iter:1<br />Sqrt(1000)=256&nbsp; Iter:2<br />Sqrt(1000)=129&nbsp; Iter:3<br />Sqrt(1000)=68&nbsp; Iter:4<br />Sqrt(1000)=41&nbsp; Iter:5<br />Sqrt(1000)=32&nbsp; Iter:6<br />Sqrt(1000)=31&nbsp; Iter:7<br />Sqrt(1000)=31&nbsp; Iter:8<br />Sqrt(1000)=31&nbsp; Iter:9<br />Sqrt(1000)=31&nbsp; Iter:10<br />Premere un tasto per continuare . . .<br />Sqrt(10000)=516&nbsp; Iter:1<br />Sqrt(10000)=267&nbsp; Iter:2<br />Sqrt(10000)=152&nbsp; Iter:3<br />Sqrt(10000)=108&nbsp; Iter:4<br />Sqrt(10000)=100&nbsp; Iter:5<br />Sqrt(10000)=100&nbsp; Iter:6<br />Sqrt(10000)=100&nbsp; Iter:7<br />Sqrt(10000)=100&nbsp; Iter:8<br />Sqrt(10000)=100&nbsp; Iter:9<br />Sqrt(10000)=100&nbsp; Iter:10<br />Premere un tasto per continuare . . .<br />Sqrt(100000)=560&nbsp; Iter:1<br />Sqrt(100000)=369&nbsp; Iter:2<br />Sqrt(100000)=320&nbsp; Iter:3<br />Sqrt(100000)=316&nbsp; Iter:4<br />Sqrt(100000)=316&nbsp; Iter:5<br />Sqrt(100000)=316&nbsp; Iter:6<br />Sqrt(100000)=316&nbsp; Iter:7<br />Sqrt(100000)=316&nbsp; Iter:8<br />Sqrt(100000)=316&nbsp; Iter:9<br />Sqrt(100000)=316&nbsp; Iter:10<br />Premere un tasto per continuare . . .<br />Sqrt(1000000)=1000&nbsp; Iter:1<br />Sqrt(1000000)=1000&nbsp; Iter:2<br />Sqrt(1000000)=1000&nbsp; Iter:3<br />Sqrt(1000000)=1000&nbsp; Iter:4<br />Sqrt(1000000)=1000&nbsp; Iter:5<br />Sqrt(1000000)=1000&nbsp; Iter:6<br />Sqrt(1000000)=1000&nbsp; Iter:7<br />Sqrt(1000000)=1000&nbsp; Iter:8<br />Sqrt(1000000)=1000&nbsp; Iter:9<br />Sqrt(1000000)=1000&nbsp; Iter:10<br />Premere un tasto per continuare . . .<br />Sqrt(10000000)=5394&nbsp; Iter:1<br />Sqrt(10000000)=3623&nbsp; Iter:2<br />Sqrt(10000000)=3191&nbsp; Iter:3<br />Sqrt(10000000)=3162&nbsp; Iter:4<br />Sqrt(10000000)=3162&nbsp; Iter:5<br />Sqrt(10000000)=3162&nbsp; Iter:6<br />Sqrt(10000000)=3162&nbsp; Iter:7<br />Sqrt(10000000)=3162&nbsp; Iter:8<br />Sqrt(10000000)=3162&nbsp; Iter:9<br />Sqrt(10000000)=3162&nbsp; Iter:10<br />Premere un tasto per continuare . . .<br />Sqrt(100000000)=49340&nbsp; Iter:1<br />Sqrt(100000000)=25683&nbsp; Iter:2<br />Sqrt(100000000)=14788&nbsp; Iter:3<br />Sqrt(100000000)=10775&nbsp; Iter:4<br />Sqrt(100000000)=10027&nbsp; Iter:5<br />Sqrt(100000000)=10000&nbsp; Iter:6<br />Sqrt(100000000)=10000&nbsp; Iter:7<br />Sqrt(100000000)=10000&nbsp; Iter:8<br />Sqrt(100000000)=10000&nbsp; Iter:9<br />Sqrt(100000000)=10000&nbsp; Iter:10<br />Premere un tasto per continuare . . .<br />Sqrt(1000000000)=488793&nbsp; Iter:1<br />Sqrt(1000000000)=245419&nbsp; Iter:2<br />Sqrt(1000000000)=124746&nbsp; Iter:3<br />Sqrt(1000000000)=66381&nbsp; Iter:4<br />Sqrt(1000000000)=40722&nbsp; Iter:5<br />Sqrt(1000000000)=32639&nbsp; Iter:6<br />Sqrt(1000000000)=31638&nbsp; Iter:7<br />Sqrt(1000000000)=31622&nbsp; Iter:8<br />Sqrt(1000000000)=31622&nbsp; Iter:9<br />Sqrt(1000000000)=31622&nbsp; Iter:10<br />Premere un tasto per continuare . . .<br />Sqrt(2147483647)=1049087&nbsp; Iter:1<br />Sqrt(2147483647)=525567&nbsp; Iter:2<br />Sqrt(2147483647)=264826&nbsp; Iter:3<br />Sqrt(2147483647)=136467&nbsp; Iter:4<br />Sqrt(2147483647)=76101&nbsp; Iter:5<br />Sqrt(2147483647)=52159&nbsp; Iter:6<br />Sqrt(2147483647)=46665&nbsp; Iter:7<br />Sqrt(2147483647)=46342&nbsp; Iter:8<br />Sqrt(2147483647)=46340&nbsp; Iter:9<br />Sqrt(2147483647)=46340&nbsp; Iter:10<br />Premere un tasto per continuare . . .<br /></code></pre></div><br /><br />einstein1969</div>
			</div>
			<hr />
					<div class="post">
				<h3>Re: Dos Batch Math Library</h3>
				<div class="date">Posted: <strong>14 Nov 2015 10:55</strong></div>
				<div class="author">by <strong>einstein1969</strong></div>
				<div class="content">There are news on speeding research.<br /><br />I have used a linear equation ( a line Y=N/(11*1024)+40 ) for guessing the square root and the I have insert in the Newthon algorithm.<br /><br />The guessing is nice and I <strong class="text-strong">doubled</strong> another time the speed.<br /><br />Now with <strong class="text-strong">5 iterations</strong> is possible calculate integer 32bit square roots.<br /><br />new code:<br /><div class="codebox"><p>Code: <a href="#" onclick="selectCode(this); return false;">Select all</a></p><pre><code>:sqrt0<br />set /A N=%1<br />if !N! neq 0 (<br /><br />&nbsp; rem set /A &quot;guess=N/(40*1024)+128, x=guess&quot; &amp; rem max 7 iterations<br />&nbsp; rem set /A &quot;guess=N/(35*1024)+64, x=guess&quot; &amp; rem max 6<br />&nbsp; rem set /A &quot;guess=N/(12*1024)+32, x=guess&quot; &amp; rem max 6<br />&nbsp; set /A &quot;guess=N/(11*1024)+40, x=guess&quot; &amp; rem max 5<br /><br /><br />&nbsp; For /L %%I in (1,1,5) do (<br /><br />&nbsp; &nbsp; set /A &quot;x=(N/x+x)/2&quot;<br />&nbsp; &nbsp; echo Sqrt(%N%^)=!x!&nbsp; Iter:%%I guess:!guess!<br />&nbsp; )<br />)<br />exit/b<br /></code></pre></div><br /><br />Now it is possible using the Aacini method in this thread <a href="viewtopic210e.html?f=3&amp;t=6744" class="postlink">Definition and use of arithmetic &quot;functions&quot; in Batch files</a>.<br /><br /><div class="codebox"><p>Code: <a href="#" onclick="selectCode(this); return false;">Select all</a></p><pre><code>@echo off<br /><br />set &quot;Sqrt(N)=( x=(N)/(11*1024)+40, x=((N)/x+x)/2, x=((N)/x+x)/2, x=((N)/x+x)/2, x=((N)/x+x)/2, x=((N)/x+x)/2 )&quot;<br /><br />set /A num=%Sqrt(N):N=25%<br />echo Square root of 25 is : %num%<br /></code></pre></div><br />result:<br /><div class="codebox"><p>Code: <a href="#" onclick="selectCode(this); return false;">Select all</a></p><pre><code>Square root of 25 is : 5<br /></code></pre></div><br />There is only a problem with Sqrt(0).<br /><br /><a href="http://fooplot.com/#W3sidHlwZSI6MCwiZXEiOiJzcXJ0KHgpIiwiY29sb3IiOiIjMDVGNzBEIn0seyJ0eXBlIjowLCJlcSI6IjEvKDExKjEwMjQpeCs0MCIsImNvbG9yIjoiIzAwMDAwMCJ9LHsidHlwZSI6MCwiZXEiOiJhYnMoc3FydCh4KS0oMS8oMTEqMTAyNCl4KzQwKSkiLCJjb2xvciI6IiNGNzA1MDUifSx7InR5cGUiOjEwMDAsIndpbmRvdyI6WyItMTE3MzcxODcyLjM3NzMyOTc0IiwiMjE2ODA2MTcyNC4xOTU0NzM3IiwiLTg5MDEuMTc1MDgxNDAyNDEzIiwiOTI5MTguMzUyNTcwODgzODEiXSwiZ3JpZCI6WyI1MDAwMDAwMDAiLCIiXX1d" class="postlink">This</a> is the graphics with the absolute error in the guess calcolous. <br /><br />einstein1969</div>
			</div>
			<hr />
					<div class="post">
				<h3>Re: Dos Batch Math Library</h3>
				<div class="date">Posted: <strong>14 Nov 2015 14:52</strong></div>
				<div class="author">by <strong>penpen</strong></div>
				<div class="content"><blockquote><div><cite>einstein1969 wrote:</cite>There is only a problem with Sqrt(0).</div></blockquote>This should be relatively easy to solve, just add one more iteration step.<br />You could also provoke an error/exception (division by zero), when processing negative integers:<br /><div class="codebox"><p>Code: <a href="#" onclick="selectCode(this); return false;">Select all</a></p><pre><code>@echo off<br />setlocal enableDelayedExpansion<br />set &quot;Sqrt(N)=( x=(N)/(11*1024)+40, x=((N)/x+x)/2, x=((N)/x+x)/2, x=((N)/x+x)/2, x=((N)/x+x)/2, x=((N)/x+x)/2, x=((N)/x+x)/2, x/=(1+(N&gt;&gt;31)))&quot;<br /><br />for %%s in (-2147483647, -1, 0, 1, 4, 9, 16, 25, 2147395600, 2147483647) do (<br />&nbsp; &nbsp;(<br />&nbsp; &nbsp;&nbsp; &nbsp;set /A &quot;num=!Sqrt(N):N=%%~s!&quot;<br />&nbsp; &nbsp;) &amp;&amp; (<br />&nbsp; &nbsp;&nbsp; &nbsp;echo Square root of %%~s is : !num!<br />&nbsp; &nbsp;) || (<br />&nbsp; &nbsp;&nbsp; &nbsp;echo Square root of %%~s is not in R.<br />&nbsp; &nbsp;)<br />)<br /><br />endlocal<br />goto :eof</code></pre></div><br /><br />penpen</div>
			</div>
			<hr />
					<div class="post">
				<h3>Re: Dos Batch Math Library</h3>
				<div class="date">Posted: <strong>15 Nov 2015 08:40</strong></div>
				<div class="author">by <strong>einstein1969</strong></div>
				<div class="content">Thanks penpen! I like the negative catch.<br /><br /><div class="codebox"><p>Code: <a href="#" onclick="selectCode(this); return false;">Select all</a></p><pre><code>&nbsp; Rem NOTE: The equation of the line is y=mx+q. <br />&nbsp; Rem The maxim for q is 31 to achieve the 0 in the 5 iteration.<br />&nbsp; Rem But for every m is not possible go down into 5 iteration. <br /></code></pre></div><br /><br />... but I have found a patch for the ZERO using only 5 iteration (my goal is speeding).<br /><br /><div class="codebox"><p>Code: <a href="#" onclick="selectCode(this); return false;">Select all</a></p><pre><code>@echo off<br />setlocal enableDelayedExpansion<br />set &quot;Sqrt(N)=( x=(N)/(11*1024)+40-^!N*9, x=((N)/x+x)/2, x=((N)/x+x)/2, x=((N)/x+x)/2, x=((N)/x+x)/2, x=((N)/x+x)/2, x/=(1+(N&gt;&gt;31)))&quot;<br /><br />for %%s in (-2147483647, -1, 0, 1, 4, 9, 16, 25, 65536, 131072, 262144, 393216, 2147395600, 2147483647) do (<br />&nbsp; &nbsp;(<br />&nbsp; &nbsp; &nbsp; set /A &quot;num=!Sqrt(N):N=%%~s!&quot;<br />&nbsp; &nbsp;) &amp;&amp; (<br />&nbsp; &nbsp; &nbsp; echo Square root of %%~s is : !num!<br />&nbsp; &nbsp;) || (<br />&nbsp; &nbsp; &nbsp; echo Square root of %%~s is not in R.<br />&nbsp; &nbsp;)<br />)<br /><br />endlocal<br />goto :eof<br /></code></pre></div><br /><br />output:<br /><div class="codebox"><p>Code: <a href="#" onclick="selectCode(this); return false;">Select all</a></p><pre><code>Errore di divisione per zero.<br />Square root of -2147483647 is not in R.<br />Errore di divisione per zero.<br />Square root of -1 is not in R.<br />Square root of 0 is : 0<br />Square root of 1 is : 1<br />Square root of 4 is : 2<br />Square root of 9 is : 3<br />Square root of 16 is : 4<br />Square root of 25 is : 5<br />Square root of 65536 is : 256<br />Square root of 131072 is : 362<br />Square root of 262144 is : 512<br />Square root of 393216 is : 627<br />Square root of 2147395600 is : 46340<br />Square root of 2147483647 is : 46340<br /></code></pre></div><br /><br /><br />einstein1969</div>
			</div>
			<hr />
					<div class="post">
				<h3>Re: Dos Batch Math Library</h3>
				<div class="date">Posted: <strong>16 Nov 2015 09:21</strong></div>
				<div class="author">by <strong>einstein1969</strong></div>
				<div class="content">I have done some test and there is a problem on the proposed code.<br /><br />The Sqrt(65535) return 256 and not 255. I have not checked other value.  <img class="smilies" src="images/smilies/icon_eek.gif" alt=":shock:" title="Shocked" /> <br /><br />I don't know if the problem is the number of iteration because:<br /><br /><strong class="text-strong">The Newton method on integer sqrt is not stable.</strong><br /><br />es.<br /><div class="codebox"><p>Code: <a href="#" onclick="selectCode(this); return false;">Select all</a></p><pre><code>@echo off<br />setlocal EnableDelayedExpansion<br /><br />call :sqrt0 65535 10<br />exit/b<br /><br />:sqrt0<br />set /A N=%1<br />if !N! geq 0 (<br /><br />&nbsp; Rem NOTE: The equation of the line is y=mx+q. <br />&nbsp; Rem The maxim for q is 31 to achieve the 0 in the 5 iteration.<br />&nbsp; Rem But for every m is not possible go down into 5 iteration. <br /><br />&nbsp; rem set /A &quot;guess=N/(40*1024)+128, x=guess&quot; &amp; rem max 7 iterations<br />&nbsp; rem set /A &quot;guess=N/(35*1024)+64, x=guess&quot; &amp; rem max 6<br />&nbsp; rem set /A &quot;guess=N/(12*1024)+32, x=guess&quot; &amp; rem max 6<br />&nbsp; rem set /A &quot;guess=N/(11*1024)+40, x=guess&quot; &amp; rem max 6 better<br /><br />&nbsp; rem workaround for ZERO.<br />&nbsp; set /A &quot;guess=N/(11*1024)+40-^!N*9, x=guess&quot; &amp; rem max 5<br /><br />&nbsp; For /L %%I in (1,1,%2) do (<br />&nbsp; &nbsp; set /A &quot;x=(N/x+x)/2&quot;<br />&nbsp; &nbsp; echo Sqrt(%N%^)=!x!&nbsp; Iter:%%I guess:!guess!<br />&nbsp; )<br />)<br />exit/b<br /></code></pre></div><br />output:<br /><div class="codebox"><p>Code: <a href="#" onclick="selectCode(this); return false;">Select all</a></p><pre><code>Sqrt(65535)=750&nbsp; Iter:1 guess:45<br />Sqrt(65535)=418&nbsp; Iter:2 guess:45<br />Sqrt(65535)=287&nbsp; Iter:3 guess:45<br />Sqrt(65535)=257&nbsp; Iter:4 guess:45<br />Sqrt(65535)=256&nbsp; Iter:5 guess:45<br />Sqrt(65535)=255&nbsp; Iter:6 guess:45<br />Sqrt(65535)=256&nbsp; Iter:7 guess:45<br />Sqrt(65535)=255&nbsp; Iter:8 guess:45<br />Sqrt(65535)=256&nbsp; Iter:9 guess:45<br />Sqrt(65535)=255&nbsp; Iter:10 guess:45</code></pre></div><br /><br />But the aacini integer sqrt return the exact result because there is a test of STOP. <strong class="text-strong">if !iter2! geq !iter1!</strong><br /><br /><div class="codebox"><p>Code: <a href="#" onclick="selectCode(this); return false;">Select all</a></p><pre><code>:Sqrt_aacini<br />setlocal EnableDelayedExpansion<br /><br />set /A number=%1<br />set /A iter1=number/2+1<br /><br />rem The maximum number of iterations to calculate sqrt of a 32 bits integer number is 20<br />set &quot;sqrt=&quot;<br />for /L %%i in (1,1,20) do if not defined sqrt (<br />&nbsp; &nbsp;set /A &quot;iter2=number/iter1, iter1=(iter1+iter2)/2&quot;<br />&nbsp; &nbsp;if !iter2! geq !iter1! set /A &quot;sqrt=(iter1+iter2)/2&quot;<br />)<br />echo Sqrt(%number%) = %sqrt%<br />exit/b<br /></code></pre></div><br />output:<br /><div class="codebox"><p>Code: <a href="#" onclick="selectCode(this); return false;">Select all</a></p><pre><code>Sqrt(65535) = 255</code></pre></div><br /><br />I don't understand this test of exit.<br /><br />If I don't resolve this question I don't go in this direction.<br /><br />Einstein1969</div>
			</div>
			<hr />
					<div class="post">
				<h3>Re: Dos Batch Math Library</h3>
				<div class="date">Posted: <strong>16 Nov 2015 13:43</strong></div>
				<div class="author">by <strong>Aacini</strong></div>
				<div class="content"><blockquote><div><cite>einstein1969 wrote:</cite>I have done some test and there is a problem on the proposed code.<br /><br />The Sqrt(65535) return 256 and not 255. I have not checked other value.  <img class="smilies" src="images/smilies/icon_eek.gif" alt=":shock:" title="Shocked" /> <br /><br />I don't know if the problem is the number of iteration because:<br /><br /><strong class="text-strong">The Newton method on integer sqrt is not stable.</strong><br /><br />. . . .<br /><br />If I don't resolve this question I don't go in this direction.<br /><br />Einstein1969</div></blockquote><br /><br />Yes. Your method fails with numbers as less as 35 or 48. The method iterates on a series of values and in each step it must produce a value <em class="text-italics">less or equal</em> than the previous one, so the method <em class="text-italics">may</em> fail when a next value is greater. I inserted the required IF command, but then realized that the test must not be applied to the first value. I inserted the test from the second value on and cut the loop to 4 cycles, but then realized that in certain cases the result was wrong and it requires an additional step. This means that it needs a total of 6 cycles.<br /><br />The code below includes all these points; it also includes the &quot;function&quot; method (although not for SET command, but as individual macro).<br /><br /><div class="codebox"><p>Code: <a href="#" onclick="selectCode(this); return false;">Select all</a></p><pre><code>@echo off<br />setlocal EnableDelayedExpansion<br /><br />set &quot;Sqrt(Num)=set /A &quot;M=(Num),sqrt=M/(11*1024)+40,sqrt=(M/sqrt+sqrt)/2&quot;&amp;(for /L %%i in (1,1,5) do set /A &quot;x2=(M/sqrt+sqrt)/2&quot;^&amp;if ^!x2^! leq ^!sqrt^! set /A sqrt=x2)&quot;<br /><br /><br />:loop<br />&nbsp; &nbsp;echo/<br />&nbsp; &nbsp;set &quot;number=&quot;<br />&nbsp; &nbsp;set /P &quot;number=Enter number: &quot;<br />&nbsp; &nbsp;if not defined number goto :EOF<br />&nbsp; &nbsp;call :sqrt0 %number%<br />&nbsp; &nbsp;echo/<br />&nbsp; &nbsp;%Sqrt(Num):Num=!number!%<br />&nbsp; &nbsp;echo Function method: %sqrt%<br />&nbsp; &nbsp;echo/<br />goto loop<br /><br /><br />:sqrt0<br />set /A N=%1<br />if %N% neq 0 (<br /><br />&nbsp; rem set /A &quot;guess=N/(40*1024)+128, x=guess&quot; &amp; rem max 7 iterations<br />&nbsp; rem set /A &quot;guess=N/(35*1024)+64, x=guess&quot; &amp; rem max 6<br />&nbsp; rem set /A &quot;guess=N/(12*1024)+32, x=guess&quot; &amp; rem max 6<br />&nbsp; set /A &quot;guess=N/(11*1024)+40, x=(N/guess+guess)/2&quot; &amp; rem max 5<br /><br />&nbsp; echo guess = !guess!<br /><br />&nbsp; For /L %%I in (1,1,5) do (<br />&nbsp; &nbsp; set /A &quot;x2=(N/x+x)/2&quot;<br />&nbsp; &nbsp; if !x2! leq !x! set /A x=x2<br />&nbsp; &nbsp; echo %%I- Sqrt(%N%^)=!x!<br />&nbsp; )<br />)<br />exit/b<br /></code></pre></div><br />Antonio</div>
			</div>
			<hr />
					<div class="post">
				<h3>Re: Dos Batch Math Library</h3>
				<div class="date">Posted: <strong>16 Nov 2015 19:42</strong></div>
				<div class="author">by <strong>penpen</strong></div>
				<div class="content"><blockquote><div><cite>einstein1969 wrote:</cite>The Sqrt(65535) return 256 and not 255. I have not checked other value.  <img class="smilies" src="images/smilies/icon_eek.gif" alt=":shock:" title="Shocked" /> <br /><br />I don't know if the problem is the number of iteration because:<br /><br /><strong class="text-strong">The Newton method on integer sqrt is not stable.</strong></div></blockquote>Right, the Newton method (aka Heron of Alexandria method) is not stable in <strong class="text-strong">N</strong>:<br />But it is not &quot;too unstable&quot;.  <img class="smilies" src="images/smilies/icon_smile.gif" alt=":)" title="Smile" /><br /><br />The value x could trigger (only) between the solution sqrt(N) (==roundOff(sqrt(N)) in integral number systems) and the successor of the solution (sqrt(N)+1):<br />If N=x*x =&gt; x==sqrt(N), and no trigger possible.<br />If N&lt;x*x =&gt; x &gt; N/x, more iterations required, but no trigger possible.<br />If N&gt;x* =&gt; trigger possible between roundOff(sqrt(N)) and (roundOff(sqrt(N))+1);<br />because of the iteration step in this case the following is true when triggering:<br />- roundOff(sqrt(N)) &lt; sqrt(N) &lt; roundOff(sqrt(N))+1,<br />- roundOff(sqrt(N)) == N/(roundOff(sqrt(N))+1), and<br />- roundOff(sqrt(N)+1) == N/roundOff(sqrt(N)).<br /><br />So in your algorithm (using int calculus) you could test if (N-x*x) is greater than or equal to 0;<br />if this is true then sqrt(N)=x, else sqrt(N)=x-1.<br />This value could be computed using set /A (but the max value is a trap; possible: x*x&gt;maxInt):<br /><div class="codebox"><p>Code: <a href="#" onclick="selectCode(this); return false;">Select all</a></p><pre><code>set /a &quot;x+=((N-((x-1)*(x-1)+(x+x-1)))&gt;&gt;31)&quot;</code></pre></div><br /><br /><br />So the whole code should be:<br /><div class="codebox"><p>Code: <a href="#" onclick="selectCode(this); return false;">Select all</a></p><pre><code>@echo off<br />setlocal enableDelayedExpansion<br />set &quot;Sqrt(N)=( x=(N)/(11*1024)+40-^!(N)*9, x=((N)/x+x)/2, x=((N)/x+x)/2, x=((N)/x+x)/2, x=((N)/x+x)/2, x=((N)/x+x)/2, x+=(((N)-((x-1)*(x-1)+(x+x-1)))&gt;&gt;31))/(1+((N)&gt;&gt;31))&quot;<br /><br />for %%s in (-2147483647, -1, 0, 1, 4, 9, 16, 25, 35, 48 65535, 65536, 65537, 131072, 262144, 393216, 2147395600, 2147483647) do (<br />&nbsp; &nbsp;(<br />&nbsp; &nbsp;&nbsp; &nbsp;2&gt;nul set /A &quot;num=!Sqrt(N):N=%%~s!&quot;<br />&nbsp; &nbsp;) &amp;&amp; (<br />&nbsp; &nbsp;&nbsp; &nbsp;echo Square root of %%~s is : !num!<br />&nbsp; &nbsp;) || (<br />&nbsp; &nbsp;&nbsp; &nbsp;setlocal enableDelayedExpansion<br />&nbsp; &nbsp;&nbsp; &nbsp;set /A &quot;num=!Sqrt(N):N=-%%~s!&quot;<br />&nbsp; &nbsp;&nbsp; &nbsp;echo Square root of %%~s is !num!i ^(not in R^).<br />&nbsp; &nbsp;&nbsp; &nbsp;endlocal<br />&nbsp; &nbsp;)<br />)<br /><br />endlocal<br />goto :eof</code></pre></div>Note:<br />I have not tested, if this algorithm computes always the correct result.<br />Some values within [0:2^31-1] may need more iterations.<br />Because of the starting value the number of iterations is not monotonically increasing anymore<br />(if i remember right then the original algorithm (initial x=N) needs a maximum of 19 iterations).<br /><br />But you should check this using c++/java/similar... batch is much too slow to check all numbers within [0:2^32-1];<br />my pc would take &gt;300 days, but it isn't the fastest... .<br /><br /><br />penpen</div>
			</div>
			<hr />
			</div>

	<div id="page-footer" class="page-footer">
		<div class="page-number">All times are <span title="UTC-6">UTC-06:00</span><br />Page <strong>2</strong> of <strong>4</strong></div>
		<div class="copyright">Powered by phpBB&reg; Forum Software &copy; phpBB Limited<br />https://www.phpbb.com/</div>
	</div>
</div>

</body>

<!-- Mirrored from www.dostips.com/forum/viewtopic.php?f=3&t=5819&start=15&view=print by HTTrack Website Copier/3.x [XR&CO'2014], Fri, 19 Oct 2018 07:05:10 GMT -->
</html>
